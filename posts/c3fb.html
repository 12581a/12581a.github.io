<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Java基础知识回顾, Zero">
    <meta name="description" content="Hello,World!">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Java基础知识回顾 | Zero</title>
    <link rel="icon" type="image/png" href="/logo.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Zero</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Zero</div>
        <div class="logo-desc">
            
            Hello,World!
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/23.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Java基础知识回顾</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    .toc-fixed .toc-link::before{
        position: fixed!important;/*当toc的位置改为fixed时，.toc-link::before也要改为fixed*/
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Java/">
                                <span class="chip bg-color">Java</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-12-29
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="Java基础知识回顾"><a href="#Java基础知识回顾" class="headerlink" title="Java基础知识回顾"></a>Java基础知识回顾</h3><h4 id="1-JVM-、JDK-和-JRE"><a href="#1-JVM-、JDK-和-JRE" class="headerlink" title="1.JVM 、JDK 和 JRE"></a>1.JVM 、JDK 和 JRE</h4><ul>
<li>Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。 </li>
<li>JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。 </li>
<li>JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。 </li>
</ul>
<p>Java程序经过JDK的javac命令编译为字节码文件，即扩展名为.class的文件,然后由JVM加载翻译为机器代码。</p>
<p> Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</p>
<h4 id="2-Java基本类型与数组"><a href="#2-Java基本类型与数组" class="headerlink" title="2.Java基本类型与数组"></a>2.Java基本类型与数组</h4><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><table>
<thead>
<tr>
<th>类型</th>
<th>型别</th>
<th>字节</th>
<th>取值范围</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>整型</td>
<td>1byte</td>
<td>-2<sup>7 </sup>~ 2<sup>7</sup>-1</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>整型</td>
<td>2byte</td>
<td>-2<sup>15</sup> ~ 2<sup>15</sup>-1</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>整型</td>
<td>4byte</td>
<td>-2<sup>31</sup> ~ 2<sup>31</sup>-1</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>整型</td>
<td>8byte</td>
<td>-2<sup>63</sup> ~ 2<sup>63</sup>-1</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>浮点型</td>
<td>4byte</td>
<td>……</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>浮点型</td>
<td>8byte</td>
<td>……</td>
<td>0.0d</td>
</tr>
<tr>
<td>char</td>
<td>字符型</td>
<td>2byte</td>
<td>……</td>
<td>‘u0000’</td>
</tr>
<tr>
<td>boolean</td>
<td>布尔型</td>
<td>1byte</td>
<td>……</td>
<td>false</td>
</tr>
</tbody></table>
<h5 id="原码，反码，补码"><a href="#原码，反码，补码" class="headerlink" title="原码，反码，补码"></a>原码，反码，补码</h5><blockquote>
<p> <strong>原码</strong>:是最简单的机器数表示法。用最高位表示符号位，‘1’表示负号，‘0’表示正号。其他位存放该数的二进制的绝对值。</p>
<p> <strong>反码：</strong>正数的反码还是等于原码。负数的反码就是他的原码除符号位外，按位取反。</p>
<p> <strong>补码：</strong>正数的补码等于他的原码。负数的补码等于反码+1。 </p>
</blockquote>
<p>计算机没法直接做减法的，它的减法是通过加法来实现的。1010 ：最高位为‘1’,表示这是一个负数，其他三位为‘010’，  即0×2<sup>0</sup>+1×2<sup>1</sup>×+0×2<sup>2</sup>=2 ， 所以1010表示十进制数-2。</p>
<p>正数之间的加法通常是不会出错的，因为它就是一个很简单的二进制加法。而正数与负数相加，或负数与负数相加，就要引起莫名其妙的结果，这都是该死的符号位引起的。0分为<code>+0</code>和<code>-0</code>也是因他而起。所以原码，虽然直观易懂，易于正值转换。但用来实现加减法的话，运算规则总归是太复杂，于是反码来了。</p>
<p>我们知道，原码最大的问题就在于一个数加上他的相反数不等于零。</p>
<p>例如：<code>0001+1001=1010 (1+(-1)=-2)</code> <code>0010+1010=1100 (2+(-2)=-4)</code></p>
<p>于是反码的设计思想就是冲着解决这一点，既然一个负数是一个正数的相反数，那我们干脆用一个正数按位取反来表示负数试试。  </p>
<p>byte 表示一个字节，一个字节是 8 位，最高位是符号位。</p>
<p>那么 8 位能表示的最大值就是 0111 1111，换算成十进制就是 127。</p>
<p>最小的负数就是1000 0000，（最大的负数是 1111 1111 是负数-1的补码），换算成十进制就是 -128， 10000000 是最小负数的补码表示形式，我们把补码计算步骤倒过来就即可。1000 0000 减 1 得  0111 1111 然后取反 1000 0000 因为负数的补码是其绝对值取反，即 1000 0000 为最小负数的绝对值，而 1000 0000 的十进制表示是 128，所以最小负数是 -128</p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>声明并且创建一个长度为2的数组</p>
<p><code>int Array[] = new int[2];</code></p>
<p>可以为数组分配元素<code>Array[0] = 1</code>,<code>Array[1] = 2</code></p>
<p>在声明数组的同时也可以给每个数组的元素一个初始值</p>
<p><code>int Array = {1,2,3,4,5,6,7,8,9}</code></p>
<p>java采用”数组的数组“声明多维数组，一个二维数组是由若干个一维数组构成的。</p>
<p><code>int a[][] = new int[][];</code></p>
<h4 id="3-java面向对象编程特性"><a href="#3-java面向对象编程特性" class="headerlink" title="3.java面向对象编程特性"></a>3.java面向对象编程特性</h4><p>一个java应用程序是由若干个类所构成的，一个class类里面的成员变量有默认值，而局部变量没有默认值。</p>
<p>如果类中没有编写构造方法，则默认有一个无参数的构造方法, 构造方法主要作用是完成对类对象的初始化工作。 </p>
<p>创建一个对象包括对象的声明和对象变量的分配。当对象声明之后，对象变量的内存中还没有任何的数据，对象变量为一个空对象，利用<code>new</code>运算符计算出一个十六进制的引用后，对象就诞生了。</p>
<p><code>Object o = new Object();</code></p>
<h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><blockquote>
<p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问. </p>
</blockquote>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><blockquote>
<p> 继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。 </p>
</blockquote>
<p>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问,只是拥有。</p>
<p><strong>对象增强的手段：继承、装饰者模式、动态代理</strong></p>
<ul>
<li><p><strong>方法重写</strong></p>
<p>重写是子类对父类的允许访问的方法的实现过程进行重新编写,发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。另外，如果父类方法访问修饰符为 private 则子类就不能重写该方法。也就是说方法提供的行为改变，而方法的外貌并没有改变。</p>
<p>方法重写的目的可以隐藏继承的方法，子类通过方法的重写可以把父类的状态和行为改变为自身的状态和行为</p>
<p><strong>重载</strong>： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。 </p>
<p><code>float hello(int a,int b){return a+b}</code></p>
<p><code>float hello(long a,int b){return a-b}</code></p>
<p><code>float hello(double a,int b){return a*b}</code></p>
</li>
<li><p><strong>对象的上转型对象</strong></p>
<p>假设Animal是Tiger的父类</p>
<p><code>Animal a = new Tiger();</code></p>
<p>对象的上转型对象的实体是由子类创建的，上转型对象不能操作子类新增的成员变量，不能调用子类新增的方法，可以访问子类继承或隐藏的成员变量。</p>
</li>
</ul>
<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><blockquote>
<p>多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）</p>
</blockquote>
<h4 id="4-接口与抽象类"><a href="#4-接口与抽象类" class="headerlink" title="4.接口与抽象类"></a>4.接口与抽象类</h4><ol>
<li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li>
<li>接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。</li>
<li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。</li>
<li>接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！也不允许使用static修饰）。</li>
<li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li>
</ol>
<p>接口中的常量与方法</p>
<p><code>public static final int MAX = 100</code></p>
<p><code>public abstract int sum(int a,int b)</code></p>
<ul>
<li><strong>接口回调</strong></li>
</ul>
<p>接口是java中的一种重要的数据类型，用接口声明的变量称作接口变量。接口属于引用型变量，接口变量中可以存放实现该接口的类的实例的引用。</p>
<p><code>Com object = new ImpleCom();</code></p>
<h4 id="5-常见关键字总结"><a href="#5-常见关键字总结" class="headerlink" title="5.常见关键字总结"></a>5.常见关键字总结</h4><h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><blockquote>
<p>final关键字主要用在三个地方：变量、方法、类。</p>
<ol>
<li>对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li>
<li>当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。</li>
<li>使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。</li>
</ol>
</blockquote>
<h5 id="static"><a href="#static" class="headerlink" title="static"></a>static</h5><blockquote>
<p>static 关键字主要有以下四种使用场景：</p>
<ol>
<li>修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量存放在 Java 内存区域的方法区。调用格式：类名.静态变量名类名.静态方法名()</li>
<li>静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</li>
<li>静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。</li>
<li>静态导包(用来导入类中的静态资源，1.5之后的新特性): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</li>
</ol>
</blockquote>
<h5 id="this"><a href="#this" class="headerlink" title="this"></a>this</h5><blockquote>
<p>this关键字用于引用类的当前实例。 例如：</p>
<p><strong>class</strong> <strong>Manager</strong> {   </p>
<p>​    Employees[] employees;         </p>
<p>​    <strong>void</strong> <strong>manageEmployees</strong>() {</p>
<p>​            <strong>int</strong> totalEmp = <strong>this</strong>.employees.length;</p>
<p>​           System.out.println(“Total employees: “ + totalEmp); </p>
<p>​           <strong>this</strong>.report();</p>
<p>}         </p>
<p>​    <strong>void</strong> <strong>report</strong>() { } }</p>
<p>在上面的示例中，this关键字用于两个地方：</p>
<ul>
<li>this.employees.length：访问类Manager的当前实例的变量。</li>
</ul>
<ul>
<li>this.report（）：调用类Manager的当前实例的方法。</li>
</ul>
<p>此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。</p>
</blockquote>
<h5 id="super"><a href="#super" class="headerlink" title="super"></a>super</h5><blockquote>
<p>super关键字用于从子类访问父类的变量和方法。 例如：</p>
<p><strong>public</strong> <strong>class</strong> <strong>Super</strong> {    </p>
<p>​        <strong>protected</strong> <strong>int</strong> number; </p>
<p>​        <strong>protected</strong> <strong>showNumber</strong>() {        </p>
<p>​                System.out.println(“number = “ + number);    } </p>
<p>​                    }  </p>
<p>​    <strong>public</strong> <strong>class</strong> <strong>Sub</strong> <strong>extends</strong> Super {    </p>
<p>​    <strong>void</strong> <strong>bar</strong>() {        </p>
<p>​        <strong>super</strong>.number = 10;        </p>
<p>​        <strong>super</strong>.showNumber();    } </p>
<p>}</p>
<p>在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 showNumber（） 方法。</p>
</blockquote>
<p>使用 this 和 super 要注意的问题：</p>
<ul>
<li>在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。</li>
<li>this、super不能用在static方法中。</li>
</ul>
<p><a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Basis/final、static、this、super.md" target="_blank" rel="noopener">参考链接</a></p>
<h4 id="6-自动拆装箱"><a href="#6-自动拆装箱" class="headerlink" title="6.自动拆装箱"></a>6.自动拆装箱</h4><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p>
<p><code>Integer i = 10 //自动装箱</code></p>
<p><strong>拆箱</strong>：将包装类型转换为基本数据类型；</p>
<p><code>int b = i //自动装箱</code></p>
<p>自动装箱都是通过包装类的<code>valueOf()</code>方法来实现的.自动拆箱都是通过包装类对象的<code>xxxValue()</code>来实现的。<code>Integer integer=Integer.valueOf(1);</code> </p>
<p><code>int i=integer.intValue();</code> </p>
<p>Java提供了与基本的数据类型相关的类，实现了对基本数据类型的封装。这些类在java.lang包中，分别是Byte、Boolean、Integer、Short、Long、Float、Double、Character。</p>
<p>为什么还要提供包装类呢？因为Java是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。比如，在集合类中，我们是无法将int 、double等类型放进去的。因为集合的容器要求元素是Object类型。为了让基本类型也具有对象的特征，就出现了包装类型，它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p>
<h4 id="7-访问权限"><a href="#7-访问权限" class="headerlink" title="7.访问权限"></a>7.访问权限</h4><p>Java 中一共有四种访问权限控制，其权限控制的大小情况是这样的：public &gt; protected &gt; default(包访问权限) &gt; private  </p>
<table>
<thead>
<tr>
<th>权限</th>
<th>同类</th>
<th>同包</th>
<th>不同包子类</th>
<th>不同包非子类</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<h4 id="8-与-equals"><a href="#8-与-equals" class="headerlink" title="8.== 与 equals"></a>8.== 与 equals</h4><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。</p>
<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<ul>
<li>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li>
<li>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li>
</ul>
<blockquote>
<pre><code class="java">public boolean equals(Object obj) {
    return (this== obj);
}</code></pre>
</blockquote>
<h4 id="9-常用实用类"><a href="#9-常用实用类" class="headerlink" title="9.常用实用类"></a>9.常用实用类</h4><h5 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h5><p>在Java中，String是一个引用类型，它本身也是一个class。Java把String类定义为final类，因此用户不能扩展String类，即String类不可以有子类。 </p>
<p><code>String s1 = &quot;Hello!&quot;;</code></p>
<p> 实际上字符串在<code>String</code>内部是通过一个<code>char[]</code>数组表示的，因此，按下面的写法也是可以的： </p>
<p><code>String s2 = new String(new char[] {&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;!&#39;});</code></p>
<ul>
<li><strong>String类常用的方法：</strong></li>
</ul>
<p>（1）是否包含字串    <code>&quot;Hello&quot;.contains(&quot;ll&quot;); // true</code></p>
<p>（2）判断当前的String对象的字符序列前缀是否是参数指定的String对象的字符序列</p>
<p><code>&quot;Hello,world!&quot;.startsWith(&quot;He&quot;); // true</code></p>
<p><code>&quot;Hello,world!&quot;.endsWith(&quot;!&quot;); // true</code></p>
<p>（3）<code>public boolean contains(String s)</code></p>
<p>（4）indexOf(String str)从当前String对象的字符序列的0索引位置开始检索首次出现str的字符序列的位置，并返回该位置</p>
<p><code>String s = &quot;I am a good cat&quot;;</code></p>
<p><code>s.indexof(&quot;a&quot;); // 值是2</code></p>
<p><code>s.lastIndexOf(&quot;a&quot;); // 值是13</code></p>
<p>（5）复制得到字符序列中的start位置至end-1位置上的字符</p>
<p><code>&quot;Hello&quot;.substring(2, 4); &quot;ll&quot;</code></p>
<p>（6）使用trim()方法可以移除字符串首尾空白字符。空白字符包括空格，\t，\r，\n：</p>
<p><code>&quot;  \tHello\r\n &quot;.trim(); // &quot;Hello&quot;</code></p>
<p>String还提供了isEmpty()和isBlank()来判断字符串是否为空和空白字符串：</p>
<p><code>&quot;&quot;.isEmpty(); // true，因为字符串长度为0</code><br><code>&quot;  &quot;.isEmpty(); // false，因为字符串长度不为0</code><br><code>&quot;  \n&quot;.isBlank(); // true，因为只包含空白字符</code><br><code>&quot; Hello &quot;.isBlank(); // false，因为包含非空白字符</code></p>
<p>（7）替换子串</p>
<p><code>String s = &quot;hello&quot;;</code><br><code>s.replace(&#39;l&#39;, &#39;w&#39;); // &quot;hewwo&quot;，所有字符&#39;l&#39;被替换为&#39;w&#39;</code></p>
<p>可以通过正则表达式来替换</p>
<p><code>String s = &quot;A,,B;C ,D&quot;;</code><br><code>s.replaceAll(&quot;[\\,\\;\\s]+&quot;, &quot;,&quot;); // &quot;A,B,C,D&quot;</code></p>
<p>（8）分割字符串</p>
<p><code>String s = &quot;A,B,C,D&quot;;</code><br><code>String[] ss = s.split(&quot;\\,&quot;); // {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;}</code></p>
<ul>
<li><p><strong>字符串与基本数据类型的转化</strong></p>
<p>要把任意基本类型或引用类型转换为字符串，可以使用静态方法<code>valueOf()</code>。这是一个重载方法，编译器会根据参数自动选择合适的方法。</p>
</li>
</ul>
<p><code>String s = String.valueOf(123456.78);</code></p>
<p> 要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为<code>int</code>类型：</p>
<p> <code>int n1 = Integer.parseInt(&quot;123&quot;); // 123</code></p>
<p>String和char[]类型可以互相转换，方法是：</p>
<p><code>char[] cs = &quot;Hello&quot;.toCharArray(); // String -&gt; char[]</code><br><code>String s = new String(cs); // char[] -&gt; String</code></p>
<h5 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h5><p>Java编译器对String做了特殊处理，使得我们可以直接用+拼接字符串。虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个可变对象，可以预分配缓冲区，这样，往<code>StringBuilder</code>中新增字符时，不会创建新的临时对象：</p>
<p>String对象的字符序列是不可修改的，与String类不同的是，StringBuffer类的对象的实体的内存空间可以自动的改变大小，便于存放一个可变的字符序列。</p>
<ul>
<li><strong>常用方法</strong></li>
</ul>
<p>（1）append方法</p>
<p><code>StringBuffer s = new StringBuffer(&quot;我喜欢&quot;);</code></p>
<p><code>s.append(&quot;打篮球&quot;);</code></p>
<p>（2）将参数str指定的字符序列插入到参数index指定的位置</p>
<p><code>insert(int index, String str)</code></p>
<p>（3）将对象实体中的字符序列翻转，并返回当前对象的引用</p>
<p><code>StringBuffer s = new StringBuffer(&quot;Hello&quot;);</code></p>
<p><code>s.reverse(); //olleH</code></p>
<p>（4）替换</p>
<p><code>StringBuffer replace(int startIndex,int endIndex, String str);</code></p>
<h5 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h5><p>在Java中，由CPU原生提供的整型最大范围是64位long型整数。使用long型整数可以直接通过CPU指令进行计算，速度非常快。如果我们使用的整数范围超过了long型怎么办？这个时候，就只能用软件来模拟一个大整数。java.math.BigInteger就是用来表示任意大小的整数。BigInteger内部用一个int[]数组来模拟一个非常大的整数。</p>
<p><code>BigInteger bi = new BigInteger(&quot;1234567890&quot;);</code><br><code>System.out.println(bi.pow(5)); // 2867971860299718107233761438093672048294900000</code></p>
<p> 对<code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算： </p>
<p><code>BigInteger i1 = new BigInteger(&quot;1234567890&quot;);</code><br><code>BigInteger i2 = new BigInteger(&quot;12345678901234567890&quot;);</code><br><code>BigInteger sum = i1.add(i2); // 12345678902469135780</code></p>
<p>和<code>long</code>型整数运算比，<code>BigInteger</code>不会有范围限制，但缺点是速度比较慢。也可以把<code>BigInteger</code>转换成<code>long</code>型</p>
<p><code>BigInteger i = new BigInteger(&quot;123456789000&quot;);</code><br><code>System.out.println(i.longValue()); // 123456789000</code></p>
<p>可以把BigInteger转换成基本类型。如果BigInteger表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用intValueExact()、longValueExact()等方法，在转换时如果超出范围，将直接抛出ArithmeticException异常。</p>
<h5 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h5><p>和<code>BigInteger</code>类似，<code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p>
<pre><code class="java">BigDecimal bd = new BigDecimal(&quot;123.4567&quot;);
System.out.println(bd.multiply(bd)); // 15241.55677489</code></pre>
<p> <code>BigDecimal</code>用<code>scale()</code>表示小数位数，例如 </p>
<p><code>BigDecimal d1 = new BigDecimal(&quot;123.4500&quot;); //4,4位小数</code></p>
<p>《阿里巴巴Java开发手册》中提到：浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。 具体原理和浮点数的编码方式有关，出现了精度丢失，我们下面直接上实例：</p>
<pre><code class="java">float a = 1.0f - 0.9f;
float b = 0.9f - 0.8f;
System.out.println(a);// 0.100000024
System.out.println(b);// 0.099999964
System.out.println(a == b);// false</code></pre>
<p>对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断。通过 setScale方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA会提示。</p>
<pre><code class="java">BigDecimal m = new BigDecimal(&quot;1.255433&quot;);
BigDecimal n = m.setScale(3,BigDecimal.ROUND_HALF_DOWN);
System.out.println(n);// 1.255</code></pre>
<ul>
<li><strong>比较BigDecimal</strong></li>
</ul>
<p>在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等</p>
<pre><code class="java">BigDecimal d1 = new BigDecimal(&quot;123.456&quot;);
BigDecimal d2 = new BigDecimal(&quot;123.45600&quot;);
System.out.println(d1.equals(d2)); // false,因为scale不同
System.out.println(d1.equals(d2.stripTrailingZeros())); // true,因为d2去除尾部0后scale变为2
System.out.println(d1.compareTo(d2)); // 0</code></pre>
<p> 必须使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于 </p>
<p>如果查看<code>BigDecimal</code>的源码，可以发现，实际上一个<code>BigDecimal</code>是通过一个<code>BigInteger</code>和一个<code>scale</code>来表示的，即<code>BigInteger</code>表示一个完整的整数，而<code>scale</code>表示小数位数：</p>
<pre><code>public class BigDecimal extends Number implements Comparable&lt;BigDecimal&gt; {
    private final BigInteger intVal;
    private final int scale;
}</code></pre><p><code>BigDecimal</code>也是从<code>Number</code>继承的，也是不可变对象。</p>
<ul>
<li><strong>总结</strong></li>
</ul>
<p>BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。</p>
<p>BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念</p>
<p>比较<code>BigDecimal</code>的值是否相等，必须使用<code>compareTo()</code>而不能使用<code>equals()</code>。 </p>
<h5 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h5><p>Arrays类的常见操作</p>
<ol>
<li>排序 : sort()</li>
<li>查找 : binarySearch()</li>
<li>比较: equals()</li>
<li>填充 : fill()</li>
<li>转列表: asList()</li>
<li>转字符串 : toString()</li>
<li>复制: copyOf()</li>
</ol>
<p><code>Arrays.asList()</code>在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个List集合。 <code>Arrays.asList()</code>是泛型方法，传入的对象必须是对象数组。 </p>
<pre><code class="java">String[] myArray = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot; }； 
List&lt;String&gt; myList = Arrays.asList(myArray);
//上面两个语句等价于下面一条语句
List&lt;String&gt; myList = Arrays.asList(&quot;Apple&quot;,&quot;Banana&quot;, &quot;Orange&quot;);</code></pre>
<p><strong>如何将数组转换为ArrayList</strong></p>
<ol>
<li>最简便的方法</li>
</ol>
<p><code>List list = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</code></p>
<ol start="2">
<li>使用 Java8 的Stream</li>
</ol>
<pre><code class="java">Integer [] myArray = { 1, 2, 3 };
List myList = Arrays.stream(myArray).collect(Collectors.toList());
//基本类型也可以实现转换（依赖boxed的装箱操作）
int [] myArray2 = { 1, 2, 3 };
List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());</code></pre>
<h5 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h5><pre><code class="java">void reverse(List list)//反转
void shuffle(List list)//随机排序
void sort(List list)//按自然排序的升序排序
void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑
void swap(List list, int i , int j)//交换两个索引位置的元素
void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。
</code></pre>
<h4 id="10-集合"><a href="#10-集合" class="headerlink" title="10.集合"></a>10.集合</h4><p><img src="/2019/12/29/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/%E9%9B%86%E5%90%88.PNG" alt></p>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p> <code>ArrayList</code>在内部使用了数组来存储所有元素。例如，一个ArrayList拥有5个元素，实际数组大小为<code>6</code>（即有一个空位，当添加一个元素并指定索引到<code>ArrayList</code>时，<code>ArrayList</code>自动移动需要移动的元素， 然后，往内部指定索引的数组位置添加一个元素，然后把<code>size</code>加<code>1</code>， 继续添加元素，但是数组已满，没有空闲位置的时候，<code>ArrayList</code>先创建一个更大的新数组，然后把旧数组的所有元素复制到新数组，紧接着用新数组取代旧数组，现在，新数组就有了空位，可以继续添加一个元素到数组末尾，同时<code>size</code>加<code>1</code>。</p>
<p><code>List</code>接口，可以看到几个主要的接口方法：</p>
<ul>
<li>在末尾添加一个元素：<code>void add(E e)</code></li>
<li>在指定索引添加一个元素：<code>void add(int index, E e)</code></li>
<li>删除指定索引的元素：<code>int remove(int index)</code></li>
<li>删除某个元素：<code>int remove(Object e)</code></li>
<li>获取指定索引的元素：<code>E get(int index)</code></li>
<li>获取链表大小（包含元素的个数）：<code>int size()</code></li>
</ul>
<h5 id="List的遍历"><a href="#List的遍历" class="headerlink" title="List的遍历"></a>List的遍历</h5><ul>
<li><strong>RandomAccess接口</strong></li>
</ul>
<blockquote>
<p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。为什么呢？我觉得还是和底层数据结构有关！<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O（1），所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O（n），所以不支持快速随机访问。<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！ </p>
</blockquote>
<p>实现了 <code>RandomAccess</code> 接口的list，优先选择普通 for 循环 ，其次 foreach,</p>
<p>未实现 <code>RandomAccess</code>接口的list，优先选择iterator遍历（foreach遍历底层也是通过iterator实现的,），大size的数据，千万不要使用普通for循环</p>
<p>普通for循环、foreach遍历、 iterator 遍历</p>
<pre><code class="java">List&lt;String&gt; list = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);
for(int i = 0;i&lt;list.size();i++){
    System.out.println(list.get(i));
}

for (String s: list) {
    System.out.println(s);
}

Iterator iterator = list.iterator();
while(iterator.hasNext()){
    String s = (String)iterator.next();
    System.out.println(s);
}</code></pre>
<h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><p><code>Map</code>是一种键-值映射表，当我们调用<code>put(K key, V value)</code>方法时，就把<code>key</code>和<code>value</code>做了映射并放入<code>Map</code>。当我们调用<code>V get(K key)</code>时，就可以通过<code>key</code>获取到对应的<code>value</code>。如果<code>key</code>不存在，则返回<code>null</code>。和<code>List</code>类似，<code>Map</code>也是一个接口，最常用的实现类是<code>HashMap</code>。 </p>
<h5 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h5><pre><code class="java">Map&lt;Object,String&gt; map =new HashMap();
        map.put(null,&quot;hello&quot;);
        map.put(&quot;k1&quot;,&quot;v1&quot;);
        Set set = map.entrySet();
        Iterator its = set.iterator();
        while(its.hasNext()){
            Map.Entry entry = (Map.Entry)its.next();
            Object key = entry.getKey();
            Object value = entry.getValue();
            System.out.println(key +&quot; &quot;+value);
}</code></pre>
<pre><code class="java">Set keySet = map.keySet();//获取键的集合
Iterator it = keySet.iterator();//迭代键的集合
    while(it.hasNext()) {
        Object key = it.next();
        Object value = map.get(key);//获取每个键所对应的值
        System.out.println(key+&quot; &quot;+value);
}</code></pre>
<h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><ul>
<li><strong>HashSet如何检查重复</strong><br>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。</li>
</ul>
<p><strong>hashCode（）与equals（）的相关规定：</strong></p>
<ol>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>两个对象相等,对两个equals方法返回true</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>
<li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li>
</ol>
<h5 id="List-Set-Map三者的区别？"><a href="#List-Set-Map三者的区别？" class="headerlink" title="List,Set,Map三者的区别？"></a>List,Set,Map三者的区别？</h5><ul>
<li><strong>List(对付顺序的好帮手)：</strong> List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</li>
<li><strong>Set(注重独一无二的性质):</strong> 不允许重复的集合。不会有多个元素引用相同的对象。</li>
<li><strong>Map(用Key来搜索的专家):</strong> 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</li>
</ul>
<h5 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h5><ul>
<li><p><strong>1. 是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</p>
</li>
<li><p><strong>2. 底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别）</p>
</li>
<li><p><strong>3. 插入和删除是否受元素位置的影响：</strong></p>
<p> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</p>
<p> ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O（1），如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></p>
</li>
<li><p><strong>4. 是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p>
</li>
<li><p><strong>5. 内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</p>
</li>
</ul>
<h5 id="equals和hashCode"><a href="#equals和hashCode" class="headerlink" title="equals和hashCode"></a>equals和hashCode</h5><p>HashMap之所以能根据key直接拿到value，原因是它内部通过空间换时间的方法，用一个大数组存储所有value，并根据key直接计算出value应该存储在哪个索引。</p>
<p>我们放入<code>Map</code>的<code>key</code>是字符串<code>&quot;a&quot;</code>，但是，当我们获取<code>Map</code>的<code>value</code>时，传入的变量不一定就是放入的那个<code>key</code>对象。换句话讲，两个<code>key</code>应该是内容相同，但不一定是同一个对象。</p>
<pre><code class="java">String key1 = &quot;a&quot;;
Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
map.put(key1, 123);
String key2 = new String(&quot;a&quot;);
map.get(key2); // 123
System.out.println(key1 == key2); // false
System.out.println(key1.equals(key2)); // true</code></pre>
<p>在Map的内部，对key做比较是通过equals()实现的，这一点和List查找元素需要正确覆写equals()是一样的，即正确使用Map必须保证：作为key的对象必须正确覆写equals()方法。我们经常使用String作为key，因为String已经正确覆写了equals()方法。但如果我们放入的key是一个自己写的类，就必须保证正确覆写了equals()方法。</p>
<p>通过key计算索引的方式就是调用key对象的hashCode()方法，它返回一个int整数。HashMap正是通过这个方法直接定位key对应的value的索引，继而直接返回value。</p>
<p>因此，正确使用<code>Map</code>必须保证：</p>
<ol>
<li>作为<code>key</code>的对象必须正确覆写<code>equals()</code>方法，相等的两个<code>key</code>实例调用<code>equals()</code>必须返回<code>true</code>；</li>
<li>作为<code>key</code>的对象还必须正确覆写<code>hashCode()</code>方法，且<code>hashCode()</code>方法要严格遵循以下规范：</li>
</ol>
<ul>
<li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等；</li>
<li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等；</li>
</ul>
<p>即对应两个实例<code>a</code>和<code>b</code>：</p>
<ul>
<li>如果<code>a</code>和<code>b</code>相等，那么<code>a.equals(b)</code>一定为<code>true</code>，则<code>a.hashCode()</code>必须等于<code>b.hashCode()</code>；</li>
<li>如果<code>a</code>和<code>b</code>不相等，那么<code>a.equals(b)</code>一定为<code>false</code>，则<code>a.hashCode()</code>和<code>b.hashCode()</code>尽量不要相等。</li>
</ul>
<p>上述第一条规范是正确性，必须保证实现，否则<code>HashMap</code>不能正常工作。</p>
<p>而第二条如果尽量满足，则可以保证查询效率，因为不同的对象，如果返回相同的<code>hashCode()</code>，会造成<code>Map</code>内部存储冲突，使存取的效率下降。</p>
<p>编写<code>equals()</code>和<code>hashCode()</code>遵循的原则是：</p>
<p><code>equals()</code>用到的用于比较的每一个字段，都必须在<code>hashCode()</code>中用于计算；<code>equals()</code>中没有使用到的字段，绝不可放在<code>hashCode()</code>中计算。</p>
<p>编写<code>equals()</code>方法如下：</p>
<pre><code class="java">public boolean equals(Object o) {
    if (o instanceof Person) {
        Person p = (Person) o;
        return Objects.equals(this.name, p.name) &amp;&amp; this.age == p.age;
    }
    return false;
}</code></pre>
<p>因此，我们总结一下<code>equals()</code>方法的正确编写方法：</p>
<ol>
<li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li>
<li>用<code>instanceof</code>判断传入的待比较的<code>Object</code>是不是当前类型，如果是，继续比较，否则，返回<code>false</code>；</li>
<li>对引用类型用<code>Objects.equals()</code>比较，对基本类型直接用<code>==</code>比较。</li>
</ol>
<p>使用<code>Objects.equals()</code>比较两个引用类型是否相等的目的是省去了判断<code>null</code>的麻烦。两个引用类型都是<code>null</code>时它们也是相等的。</p>
<p>编写<code>hashCode()</code>方法：</p>
<pre><code class="java">int hashCode() {
    return Objects.hash(firstName, lastName, age);
}</code></pre>
<p>所以，编写<code>equals()</code>和<code>hashCode()</code>遵循的原则是：</p>
<p><code>equals()</code>用到的用于比较的每一个字段，都必须在<code>hashCode()</code>中用于计算；<code>equals()</code>中没有使用到的字段，绝不可放在<code>hashCode()</code>中计算。</p>
<p>另外注意，对于放入<code>HashMap</code>的<code>value</code>对象，没有任何要求。</p>
<h5 id="HashMap-和-HashSet区别"><a href="#HashMap-和-HashSet区别" class="headerlink" title="HashMap 和 HashSet区别"></a>HashMap 和 HashSet区别</h5><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p>
<table>
<thead>
<tr>
<th>HashMap</th>
<th>HashSet</th>
</tr>
</thead>
<tbody><tr>
<td>实现了Map接口</td>
<td>实现Set接口</td>
</tr>
<tr>
<td>存储键值对</td>
<td>仅存储对象</td>
</tr>
<tr>
<td>调用 <code>put（）</code>向map中添加元素</td>
<td>调用 <code>add（）</code>方法向Set中添加元素</td>
</tr>
<tr>
<td>HashMap使用键（Key）计算Hashcode</td>
<td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，</td>
</tr>
</tbody></table>
<h4 id="11-泛型"><a href="#11-泛型" class="headerlink" title="11.泛型"></a>11.泛型</h4><p> 泛型就是定义一种模板，例如<code>ArrayList</code>，然后在代码中为用到的类创建对应的<code>ArrayList&lt;类型&gt;</code>，</p>
<pre><code class="java">ArrayList&lt;String&gt; strList = new ArrayList&lt;String&gt;();</code></pre>
<p> 这样一来，既实现了编写一次，万能匹配，又通过编译器保证了类型安全：这就是泛型。 </p>
<p> 注意泛型的继承关系：可以把<code>ArrayList</code>向上转型为<code>List</code>（<code>T</code>不能变！)</p>
<h5 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h5><pre><code class="java">public class Generic&lt;T&gt;{ 
    //key这个成员变量的类型为T,T的类型由外部指定  
    private T key;
    public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定
        this.key = key;
    }
    public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定
        return key;
    }
}</code></pre>
<h5 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h5><p>除了<code>ArrayList</code>使用了泛型，还可以在接口中使用泛型。例如，<code>Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code>Comparable</code>这个泛型接口。</p>
<pre><code>public interface Comparable&lt;T&gt; {
    /**
     * 返回-1: 当前实例比参数o小
     * 返回0: 当前实例与参数o相等
     * 返回1: 当前实例比参数o大
     */
    int compareTo(T o);
}</code></pre><p>泛型是一种类似”模板代码“的技术，不同语言的泛型实现方式不一定相同。</p>
<p>Java语言的泛型实现方式是擦拭法（Type Erasure）。</p>
<p>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。</p>
<p> Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型<code>T</code>视为<code>Object</code>处理，但是，在需要转型的时候，编译器会根据<code>T</code>的类型自动为我们实行安全地强制转型。 </p>
<p>要实例化<code>T</code>类型，我们必须借助额外的<code>Class</code>参数：</p>
<pre><code>public class Pair&lt;T&gt; {
    private T first;
    private T last;
    public Pair(Class&lt;T&gt; clazz) {
        first = clazz.newInstance();
        last = clazz.newInstance();
    }
}</code></pre><p>上述代码借助<code>Class</code>参数并通过反射来实例化<code>T</code>类型，使用的时候，也必须传入<code>Class</code>。例如：</p>
<pre><code>Pair&lt;String&gt; pair = new Pair&lt;&gt;(String.class);</code></pre><p>因为传入了<code>Class</code>的实例，所以我们借助<code>String.class</code>就可以实例化<code>String</code>类型。</p>
<h5 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h5><p> 一个类可以继承自一个泛型类。  在继承了泛型类型的情况下，子类可以获取父类的泛型类型。</p>
<h5 id="上下界通配符"><a href="#上下界通配符" class="headerlink" title="上下界通配符"></a>上下界通配符</h5><p>使用<code>&lt;? extends Number&gt;</code>的泛型定义称之为上界通配符，即把泛型类型的上界限定在<code>Number</code>了，除了可以传入<code>Pair&lt;Number&gt;</code>类型，我们还可以传入<code>Pair&lt;Double&gt;</code>类型，<code>Pair&lt;BigDecimal&gt;</code>类型等等，因为<code>Double</code>和<code>BigDecimal</code>都是<code>Number</code>的子类。 </p>
<p> 使用<code>extends</code>通配符表示可以读，不能写。 </p>
<p>使用类似<code>&lt;? super Integer&gt;</code>通配符作为方法参数时表示：</p>
<ul>
<li>方法内部可以调用传入<code>Integer</code>引用的方法，例如：<code>obj.setFirst(Integer n);</code>；</li>
<li>方法内部无法调用获取<code>Integer</code>引用的方法（<code>Object</code>除外），例如：<code>Integer n = obj.getFirst();</code>。</li>
</ul>
<p>即使用<code>super</code>通配符表示只能写不能读。</p>
<h4 id="12-反射"><a href="#12-反射" class="headerlink" title="12.反射"></a>12.反射</h4><p>反射的原理</p>
<p>应用在一些通用性比较高的代码中，后面学习到的框架，大多数都是使用反射来实现的。在框架开发中，都是基于配置文件来开发的。在配置文件中配置了类，可以通过反射得到类中的所有的内容，可以让类中的某个方法执行。</p>
<p>将java文件保存到硬盘(.java文件），编译java文件，得到(.class)文件，使用JVM，把class文件通过类加载器加载到内存中。万事万物皆对象，class文件在内存中使用class类表示。当使用反射时，首先需要获取到class类，得到了这个类之后，就可以得到Class文件里面的所有的内容，包括属性、构造方法、普通方法。属性通过一个类File、构造方法通过Constructor、普通方法通过Method。 </p>
<p>使用反射首先需要得到Class类：类名.class、对象.getClass()、使用Class.forName(“路径”)</p>
<pre><code class="java">//获取class类
Class c1 = Person.class;
Class c2 = new Person().getClass();
Class c3 = Class.forName(&quot;cn.text.text01.Person&quot;);</code></pre>
<p>可以不通过new，得到实例 <code>Person p = (Person)c3.newInstance();</code> </p>
<h4 id="13-并发"><a href="#13-并发" class="headerlink" title="13.并发"></a>13.并发</h4><h5 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h5><ul>
<li>进程是代码在数据集合上的一次运行活动， 是系统进行资源分配和调度的基本单位，进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</li>
<li>线程则是进程的一个执行路径， 一个进程中至少有一个线程，进程中 的多个线程共享进程的资源。</li>
</ul>
<p>程序计数器</p>
<h5 id="java中的线程"><a href="#java中的线程" class="headerlink" title="java中的线程"></a>java中的线程</h5><p><strong>1.线程的状态与生命周期</strong></p>
<ul>
<li><p>新建：当一个<code>Thread</code>类或其子类的对象被声明并创建时，新生的线程对象处于新建状态。此时它已经有了相应的内存空间和其他资源</p>
</li>
<li><p>运行：线程创建之后仅仅是占有了内存资源，在JVM管理的线程中还没有这个线程，此线程调用<code>start()</code>方法通知JVM，这样JVM就会知道又有一个新线程排队等候切换了。</p>
</li>
<li><p>中断：有4种原因的中断。<strong>a.</strong>线程使用CPU资源期间，执行了<code>sleep(int millsecond)</code>方法，是当前线程处于休眠状态。<strong>b.</strong>执行了<code>wait()</code>方法，使当前线程进入等待状态。<strong>c.</strong>线程执行某个操作进入阻塞状态<strong>d.</strong>JVM将CPU的资源从当前线程切换给其他线程，使本线程让出CPU的使用权处于中断状态。</p>
</li>
<li><p>死亡</p>
</li>
</ul>
<p><strong>2.线程的创建与运行</strong></p>
<p>Java 中有三种线程创建方式，分别为实现 Runnable 接口的 run 方法，继承 Thread 类 并重写 run 的方法，使用 Fu阳reTask 方式。</p>
<pre><code class="java">public class ThreadTest extends Thread{
    public void run() {
        System.out.println(&quot;Hello啊&quot;);
    }
    public static void main(String[] args) {
        ThreadTest t = new ThreadTest();
        t.start();
    }
}</code></pre>
<pre><code class="java">public class ThreadRunnable implements Runnable{
    @Override
    public void run() {
        System.out.println(&quot;I am a thread&quot;);
    }

    public static void main(String[] args) {
        ThreadRunnable t = new ThreadRunnable();
        new Thread(t).start();
    }
}</code></pre>
<pre><code class="java">public class ThreadCaller implements Callable&lt;String&gt;{
    @Override
    public String call() throws Exception {
        return &quot;Hello&quot;;
    }

    public static void main(String[] args) {
        //创建异步任务
        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(new ThreadCaller());
        //启动线程
        new Thread(futureTask).start();
        try{
            //等待任务执行完毕，并返回结果
            String result = futureTask.get();
            System.out.println(result);
        }catch(InterruptedException | ExecutionException e){
            e.printStackTrace();
        }
    }
}</code></pre>
<p>小结 ： 使用继承方式的好处是方便传参，你可以在子类里面添加成员变量，通过 set 方法设置参数或者通过构造函数进行传递，而如果使用 Runnable 方式，则只能使用主线 程里面被声明为 final 的变量。不好的地方是 Java 不支持多继承，如果继承了 Thread 类， 那么子类不能再继承其他类，而 Runable 则没有这个限制。前两种方式都没办法拿到任务 的返回结果，但是 Futuretask 方式可以。</p>
<h5 id="理解线程上下文切换"><a href="#理解线程上下文切换" class="headerlink" title="理解线程上下文切换"></a>理解线程上下文切换</h5><blockquote>
<p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p>
<p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
</blockquote>
<h5 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h5><ul>
<li><p><strong>什么是线程死锁</strong></p>
<p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象， 在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去</p>
</li>
</ul>
<blockquote>
<p>死锁的产生必须具备以 下四个条件。<br>· 互斥条件： 指线程对己经获取到的资源进行排它性使用 ， 即该资源同时只由一个线 程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资 源的线程释放该资源。</p>
<p> · 请求并持有条件 ： 指一个线程己经持有了至少一个资源， 但又提出了新的资源请求， 而新资源己被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己经获取的资源。</p>
<p> · 不可剥夺条件 ： 指线程获取到的资源在自己使用完之前不能被其他线程抢占， 只有 在自己使用完毕后才由 自 己释放该资源。</p>
<p> · 环路等待条件 ： 指在发生死锁时， 必然存在一个线程→资源的环形链， 即线程集合 {TO , TL T2，…， Tn｝中 的 TO 正在等待一个 Tl 占用 的资源， Tl 正在等待 T2 占 用的资源，……Tn 正在等待己被 TO 占用的资源。</p>
</blockquote>
<ul>
<li>如何避免死锁？</li>
</ul>
<p><strong>破坏互斥条件</strong></p>
<p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p>
<p><strong>破坏请求与保持条件</strong></p>
<p>一次性申请所有的资源。</p>
<p><strong>破坏不剥夺条件</strong></p>
<p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p>
<p><strong>破坏循环等待条件</strong></p>
<p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p>
<h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h5><blockquote>
<p>ThreadLocal 是 JDK 包提供的，它提供了线程本地变量，也就是如果你创建了 一个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的一个本地副本。 当多 个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问 题。创建一个 ThreadLocal 变量后，每个线程都会复制一个变量到自己的本地内存</p>
</blockquote>
<h5 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h5><blockquote>
<p>synchronized 块是 Java 提供的一种原子性内置锁， Java 中的每个对象都可以把它当作 一个同步锁来使用 ， 这些 Java 内置的使用者看不到的锁被称为内部锁，也叫作监视器锁。 线程的执行代码在进入 synchronized 代码块前会自动获取内部锁，这时候其他线程访问该 同步代码块时会被阻塞挂起。拿到内部锁的线程会在正常退出同步代码块或者抛出异常后 或者在同步块内调用了该内置锁资源的 wait 系列方法时释放该内置锁。 内置锁是排它锁， 也就是当一个线程获取这个锁后， 其他线程必须等待该线程释放锁后才能获取该锁。</p>
</blockquote>
<h4 id="14-Java8新特性"><a href="#14-Java8新特性" class="headerlink" title="14.Java8新特性"></a>14.Java8新特性</h4><h5 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h5><p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。 </p>
<p>排列字符串</p>
<pre><code class="java">List&lt;String&gt; list = Arrays.asList(&quot;Tom&quot;,&quot;City&quot;,&quot;Jone&quot;,&quot;Alice&quot;,&quot;Robby&quot;);
Collections.sort(list, new Comparator&lt;String&gt;() {
            @Override
            public int compare(String o1, String o2) {
                return o1.compareTo(o2);
            }
});</code></pre>
<p>我们可以使用Lambda表达式</p>
<pre><code class="java">Collections.sort(list, (String a, String b) -&gt; {
    return b.compareTo(a);
});</code></pre>
<p>我们还可以写的更加的简短</p>
<pre><code class="java">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</code></pre>
<p>我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 <code>@FunctionalInterface</code>注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。</p>
<pre><code class="java">//转换器
@FunctionalInterface
    interface Converter&lt;T,V&gt;{
        T convert(V from);
}
Converter&lt;Integer,String&gt; converter = from -&gt; Integer.parseInt(from);
Integer c = converter.convert(&quot;123&quot;);
System.out.println(c);</code></pre>
<h5 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h5><p>方法引用通过方法的名字来指向一个方法。</p>
<p>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p>
<p>方法引用使用一对冒号 <strong>::</strong> 。</p>
<p>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用 , 上面的代码还可以通过静态方法引用来表示： </p>
<pre><code class="java">Converter&lt;Integer,String&gt; converter = Integer::parseInt;</code></pre>
<p> 接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类： </p>
<pre><code class="java">class Person {
    String firstName;
    String lastName;

    Person() {}

    Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}</code></pre>
<p> 接下来我们指定一个用来创建Person对象的对象工厂接口： </p>
<pre><code class="java">interface PersonFactory&lt;P extends Person&gt; {
    P create(String firstName, String lastName);
}</code></pre>
<p> 这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂： </p>
<pre><code class="java">PersonFactory&lt;Person&gt; personFactory = Person::new;
Person person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;);</code></pre>
<p> 我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。 </p>
<p> <strong>lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）</strong> </p>
<h5 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h5><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为 lambda 表达式。</p>
<p> Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下： </p>
<pre><code class="java">interface Formula {
    double calculate(int a);

    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}</code></pre>
<p>Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。 </p>
<pre><code class="java">Formula formula = new Formula() {
    @Override
    public double calculate(int a) {
        return sqrt(a * 100);
    }
};
formula.calculate(100);     // 100.0
formula.sqrt(16);           // 4.0</code></pre>
<p>接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。Lambda表达式中是无法访问到默认方法的，以下代码将无法编译： </p>
<pre><code class="java">Formula formula = (a) -&gt; sqrt( a * 100);
Built-in Functional Interfaces</code></pre>
<p> JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。 </p>
<h5 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h5><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>
<li>数据源 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li>
<li>聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li>
</ul>
<p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p>
<ul>
<li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>
<li><strong>内部迭代</strong>： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li>
</ul>
<h5 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h5><ul>
<li><strong>Clock时钟</strong></li>
</ul>
<p>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。 </p>
<pre><code class="java">Clock clock = Clock.systemDefaultZone();
long millis = clock.millis();
System.out.println(millis);</code></pre>
<ul>
<li><strong>Timezones 时区</strong> </li>
</ul>
<p>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。 </p>
<pre><code class="java">ZoneId currentZone = ZoneId.systemDefault();
System.out.println(&quot;当期时区: &quot; + currentZone);</code></pre>
<ul>
<li><strong>LocalDateTime</strong></li>
</ul>
<pre><code class="java">LocalDateTime currentTime = LocalDateTime.now();
System.out.println(&quot;当前时间: &quot; + currentTime);</code></pre>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://12581a.github.io" rel="external nofollow noreferrer">Zero</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://12581a.github.io/posts/c3fb.html">https://12581a.github.io/posts/c3fb.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://12581a.github.io" target="_blank">Zero</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Java/">
                                    <span class="chip bg-color">Java</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/8fcd.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="J2EE基础知识回顾">
                        
                        <span class="card-title">J2EE基础知识回顾</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            1.Servlet总结
Servlet是javaWeb的三大组件之一，它属于动态资源。Servlet的作用是请求处理，服务器会把接收到的请求交给Servlet来处理，在Servlet中通常需要接收请求数据、处理请求，完成响应。在Java W
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2019-12-30
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Zero
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/e7f7.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="SQL语句">
                        
                        <span class="card-title">SQL语句</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            SQL语句
基本查询

SELECT column_name,column_name FROM table_name;
SELECT * FROM table_name;
SELECT DISTINCT column_name FROM t
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2019-12-27
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Zero
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/SQL/">
                        <span class="chip bg-color">SQL</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="https://12581a.github.io" target="_blank">Zero</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/12581a" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:mailto:2765221869@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2765221869" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2765221869" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
