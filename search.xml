<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySql</title>
      <link href="/posts/3ee1.html"/>
      <url>/posts/3ee1.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h1><p><strong>1.什么是MySql</strong></p><p>MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。 </p><p><strong>2.存储引擎</strong></p><p>通过下面的命令查看默认的存储引擎：<code>mysql&gt; show variables like &#39;%storage_engine%&#39;;</code></p><p>查看表的存储引擎:<code>show table status like &quot;table_name&quot; ;</code></p><p>MyISAM和InnoDB区别:</p><ol><li><p>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； </p></li><li><p>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； </p></li><li><p>InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁；</p></li><li><p>InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</p><p>MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p><p>也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。</p></li><li><p>InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键），而MyISAM可以没有；</p></li></ol><p>InnoDB为什么推荐使用自增ID作为主键？</p><p>自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</p><p><strong>3.事务</strong></p><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p>事务的四大特性：</p><ol><li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li><li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><p>并发读问题：</p><ul><li><p><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p><p>读到了另一事务未提交更新数据，即读取到了脏数据。</p></li><li><p><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p><p>对同一记录的两次读取不一致哦，因为另一事务对该记录做了修改。</p></li><li><p><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><p>对同一张表的两次查询不一致，因为另一事务插入了一条记录。</p></li></ul><p>查看MySql的隔离级别：<code>show variables like &#39;%isolation&#39;;</code></p><p>事务的四大隔离级别：</p><ul><li>SERIALIZABLE(串行化)</li><li>REPEATABLE READ(可重复读)</li><li>READ COMMITTED(读已提交的数据)</li><li>READ UNCOMMITTED(读未提交的数据)</li></ul><p>MySql默认的隔离级别是：可重复读</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻影读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p><strong>4.Mysql逻辑架构</strong></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/12581a/cdn/images/MySql1.png" alt></p><p>MySQL逻辑架构整体分为三层，最上层为客户端层，并非MySQL所独有，诸如：连接处理、授权认证、安全等功能均在这一层处理。</p><p>MySQL大多数核心服务均在中间这一层，包括查询解析、分析、优化、缓存、内置函数(比如：时间、数学、加密等函数)。所有的跨存储引擎的功能也在这一层实现：存储过程、触发器、视图等。</p><p>最下层为存储引擎，其负责MySQL中的数据存储和提取。和Linux下的文件系统类似，每种存储引擎都有其优势和劣势。中间的服务层通过API与存储引擎通信，这些API接口屏蔽了不同存储引擎间的差异。</p><p>每一个客户端发起一个新的请求都由服务器端的连接/线程处理工具负责接收客户端的请求并开辟一个新的内存空间，在服务器端的内存中生成一个新的线程，当每一个用户连接到服务器端的时候就会在进程地址空间里生成一个新的线程用于响应客户端请求，用户发起的查询请求都在线程空间内运行， 结果也在这里面缓存并返回给服务器端。线程的重用和销毁都是由连接/线程处理管理器实现的。</p><p>综上所述：用户发起请求，连接/线程处理器开辟内存空间，开始提供查询的机制。</p><p><strong>5.MySQL查询过程</strong></p><p>用户总是希望MySQL能够获得更高的查询性能，最好的办法是弄清楚MySQL是如何优化和执行查询的。一旦理解了这一点，就会发现：很多的查询优化工作实际上就是遵循一些原则让MySQL的优化器能够按照预想的合理方式运行而已。</p><p>当向MySQL发送一个请求的时候，MySQL到底做了些什么呢？下图展示了MySQL的查询过程。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/12581a/cdn/images/MySql2.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis</title>
      <link href="/posts/365f.html"/>
      <url>/posts/365f.html</url>
      
        <content type="html"><![CDATA[<p><strong>1.什么是Mybatis?</strong></p><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p><p>springboot与mybatis整合：</p><p>UserMapper文件</p><pre><code class="java">@Mapperpublic interface UserMapper {    @Select(&quot;select * from user where id=#{id}&quot;)    User getUserById(Integer id);    @Delete(&quot;delete from user where id=#{id}&quot;)    int deleteById(Integer id);}</code></pre><p>然后直接在Controller中调用就行了。</p><pre><code class="java">@RestControllerpublic class UserController {    @Autowired    private UserMapper userMapper;    @GetMapping(&quot;user/{id}&quot;)    public User getUserById(@PathVariable(&quot;id&quot;) Integer id){        User user = userMapper.getUserById(id);        return user;    }}</code></pre><p>application配置文件</p><pre><code class="properties">spring:  datasource:    username: root    password: 123456    url: jdbc:mysql://localhost:3306/test?serverTimezone=UTC    type: com.alibaba.druid.pool.DruidDataSourcemybatis:  config-location: classpath:mybatis/mybatis-config.xml  mapper-locations: classpath:mybatis/mapper/*.xml</code></pre><p><strong>2.#{}和${}的区别是什么？</strong></p><p> <code>#{}</code>表示一个占位符 ，如<code>select * from user where id=#{id}</code>, Mybatis 会将 sql 中的<code>#{}</code>替换为<code>?</code>号 。</p><p> <code>${}</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，如在配置数据源时<code>&lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;</code></p><p><strong>3.Insert, Update, Delete 元素的属性</strong> </p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>id</code></td><td align="left">在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td align="left"><code>parameterType</code></td><td align="left">将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。</td></tr><tr><td align="left"><code>resultType</code></td><td align="left">结果的类型。通常 MyBatis 可以推断出来，但是为了更加准确，写上也不会有什么问题。MyBatis 允许将任何简单类型用作主键的类型，包括字符串。如果生成列不止一个，则可以使用包含期望属性的 Object 或 Map。</td></tr></tbody></table><p> 解决列名不匹配的方式:</p><pre><code class="xml">&lt;select id=&quot;selectUsers&quot; resultType=&quot;User&quot;&gt;  select user_id as &quot;id&quot;,user_name as &quot;userName&quot;,hashed_password as &quot;hashedPassword&quot; from     some_table where id = #{id}&lt;/select&gt;</code></pre><p>上面的例子没有一个需要显式配置 <code>ResultMap</code>，这就是 <code>ResultMap</code> 的优秀之处——你完全可以不用显式地配置它们。 那显式使用外部的 <code>resultMap</code> 会怎样:</p><pre><code class="xml">&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&gt;  &lt;id property=&quot;id&quot; column=&quot;user_id&quot; /&gt;  &lt;result property=&quot;username&quot; column=&quot;user_name&quot;/&gt;  &lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&gt;&lt;/resultMap&gt;</code></pre><p> 然后在引用它的语句中设置 <code>resultMap</code> 属性就行了（注意我们去掉了 <code>resultType</code> 属性）。比如: </p><pre><code class="xml">&lt;select id=&quot;selectUsers&quot; resultMap=&quot;userResultMap&quot;&gt;  select user_id, user_name, hashed_password  from some_table  where id = #{id}&lt;/select&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础</title>
      <link href="/posts/480d.html"/>
      <url>/posts/480d.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h1><p>虚拟机安装Linux时，虚拟机的网络连接三种形式说明：</p><p>1.桥连接：Linux可以和其它系统通信，但是可能造成IP冲突。</p><p>2.NAT：网络地址转换方式：Linux可以访问外网，不会造成IP冲突。</p><p>3.主机模式：Linux是一个独立的主机，不能访问外网。</p><p><strong>一、Linux常用命令</strong>：</p><p>获取帮助信息：<code>man 指令</code>，<code>help 指令</code>，如<code>man ls</code></p><p>打印当前工作路径：<code>pwd</code></p><p>切换当前目录：<code>cd 路径</code>，返回上一级<code>cd ../</code></p><p>创建目录：<code>mkdir</code></p><p>删除，<code>rm</code>常用选项 <code>-r</code>(递归删除整个文件夹)</p><p>创建文件，可以一次创建多个:<code>touch</code></p><p>移动和重命名:<code>mv</code>,例如a.txt重命名，直接执行<code>mv a.txt b.txt</code></p><p>复制文件：<code>cp 来源文件 目标文件</code></p><p>查看文件内容:<code>cat</code>,<code>-n</code>可以显示行号。<code>cat ** | more</code>可以分页显示。</p><p>分屏查看文件内容，大型文件来看：<code>less</code></p><p><code>ls -l &gt;文件</code>:把列表的内容写入文件中</p><p><code>ls -l &gt;&gt; 文件</code>:把列表的内容追写入到文件中</p><p><code>echo &quot;hello&quot; &gt;&gt; t.txt</code>：把hello写到t.txt中。<code>echo $PATH</code>:输出当前环境变量的路径</p><p><code>head</code>:显示文件的开头部分。<code>head -n 5 文件</code>:显示前5行的内容。</p><p><code>tail</code>:输出文件尾部的部分。<code>tail -n 5 文件</code>:显示倒数5行的内容。<code>tail -f 文件</code>：追踪该文档的所有更新。</p><p><code>date</code>来设置时间：<code>date -s &quot;2020-01-01 01:01:01&quot;</code></p><p>日历显示：<code>cal 2020</code></p><p><code>find</code>: find+搜索范围+选项 eg:<code>find /home -name Hello.txt</code>    </p><p><code>grep</code>指令与管道符号：grep过滤查找，<code>&quot;|&quot;</code>表示将前一个命令的处理结果输出传递给后面的命令处理。</p><p><code>uname -r</code>:查看内核版本</p><p><code>df</code>:查看磁盘的空间，<code>df -h</code></p><p><code>free</code>:查看内存的使用情况，<code>free -m</code></p><p><strong>二、vim编辑器</strong></p><p>vim三种模式：命令模式，编辑模式，命令行模式</p><p>光标进到行首：<code>shift+6</code>;行尾<code>shift+4</code></p><p>首行<code>gg</code>；末行<code>G</code></p><p>翻屏：<code>ctrl+b</code>  ; <code>ctrl+f</code></p><p>复制光标所在行:<code>yy</code>； 复制多行 <code>数字yy</code>；粘贴<code>p</code></p><p>可视化复制：<code>ctrl+v</code></p><p>剪切/删除：按键<code>dd</code>，<code>数字dd</code>，D(删除之后当前行会变成空白行）</p><p>撤销：<code>:u</code></p><p>恢复之前的撤销操作：<code>ctrl+r</code></p><p><code>数字+G</code>:将光标移动到指定的行</p><p><code>数字↑↓</code>：移动多少行，左右移动同理</p><p>查找某个单词：在命令行下,<code>/+关键字</code></p><p><strong>命令行模式</strong></p><p>保存操作：</p><p>输入：<code>&quot;:w&quot;</code>，保存文件；退出：<code>&quot;:q&quot;</code>；保存并退出：<code>&quot;wq&quot;</code>；强制退出：<code>&quot;:q!&quot;</code>；取消高亮：<code>&quot;:nohl&quot;</code></p><p>替换：<code>&quot;:s/搜索的关键词/新的内容&quot;</code>，替换光标所在行的第一处符合条件的内容</p><p>“:s/搜索的关键词/新的内容/g”，替换光标所在行的全部符合条件的内容</p><p>“:%s/搜索的关键词/新的内容”，替换整个文档的第一处符合条件的内容</p><p>“:%s/搜索的关键词/新的内容/g”，替换整个文档的符合条件的内容</p><p>在命令行下，显示行号</p><p><code>&quot;:set nu&quot;  set nonu</code></p><p>使用vim同时打开多个文件，在末行模式下进行切换文件</p><p>查看已打开的文件名称:<code>files</code></p><p>切换文件的方式：<code>:open 文件名称</code></p><p>通过其他的命令打开上一个或下一个：<code>:bn</code>,切换到下一个文件；<code>:bp</code>,切换到上一个文件</p><p><strong>编辑模式</strong>：按<code>i</code>或<code>a</code></p><p>代码着色：<code>:syntax on</code>；<code>:syntax off</code></p><p>vim计算器的使用，进入编辑模式，<code>ctrl+r</code></p><p><strong>三、Linux用户与用户组管理</strong></p><p>任何一个要使用系统资源的用户，必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统，Linux的用户至少要属于一个组。</p><p>添加用户：<code>useradd 【选项】用户名</code>，在HOME目录下就有这个用户了。</p><p><code>useradd -d</code>指定目录 新的用户名，给新创建的用户指定家目录</p><p>指定密码：<code>passwd 用户名</code></p><p>删除用户：<code>userdel 用户名</code>，可以加选项-r，表示不保留家目录。</p><p>查询用户信息：<code>id 用户名</code> </p><p>从高权限向低权限用户切换：<code>su -**</code></p><p>当需要返回原来用户时，使用<code>exit</code>指令。</p><p>查看当前用户：<code>whoami</code></p><p>增加组：<code>groupadd 组名</code></p><p>删除组：<code>groupdel 组名</code></p><p><code>useradd -g 用户组 用户名</code>：增加用户时直接加上组。</p><p>修改用户的组：<code>usermod -g 用户组 用户名</code></p><p>用户和组的相关的配置文件：/etc/passwd、/etc/group、/etc/shadow</p><p><code>chgrp</code> ：改变文件所属群组 </p><p><code>chown</code> ：改变文件拥有者 </p><p><code>chmod</code> ：改变文件的权限, SUID, SGID, SBIT 等等的特性 </p><p>各权限的分数对照表如下： r:4 w:2 x:1 </p><p>x是excuteable；d：代表的是文件夹； -：代表的是文件<br> 第一组的wrx代表的是自己的读写执行<br> 第二组的代表的是自己组下的读写执行<br> 第三组代表的是不在自己组下的读写执行权限</p><p>网络相关命令：ping:检测主机与目标主机的联通性，如：ping 主机地址、ip地址、域名</p><p>netstat:查看网络的连接信息</p><p>压缩与解压缩：</p><p><code>tar -zcvf a.tar.gz 1.txt 2.txt</code>:把1和2.txt打包</p><p><code>tar -zxvf a.tar.gz</code>解压</p><p><code>tar -zxvf a.tar.gz -c /opt</code>:解压到指定的目录。</p><p>开源镜像网站：</p><p><a href="http://mirrors.sohu.com/mysql/" target="_blank" rel="noopener">http://mirrors.sohu.com/mysql/</a></p><p><a href="http://mirrors.ustc.edu.cn/mysql-ftp/Downloads/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/mysql-ftp/Downloads/</a></p><p><a href="http://segmentfault.com/a/1190000000375848" target="_blank" rel="noopener">http://segmentfault.com/a/1190000000375848</a></p><p><a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/posts/43de.html"/>
      <url>/posts/43de.html</url>
      
        <content type="html"><![CDATA[<h1 id="JVM概述"><a href="#JVM概述" class="headerlink" title="JVM概述"></a>JVM概述</h1><h2 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1.运行时数据区域"></a>1.运行时数据区域</h2><p>Java 虚拟机在执行 Java 程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java 虚拟机规范将 JVM 所管理的内存分为以下几个运行时数据区：程序计数器、Java 虚拟机栈、本地方法栈、Java 堆、方法区。 </p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/12581a/cdn/images/jvmdata.png" alt></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>一块较小的内存空间，它是<strong>当前线程所执行的字节码的行号指示器</strong>，字节码解释器工作时通过改变该计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能都要依赖它来实现。每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。</p><p>当线程在执行一个 Java 方法时，该计数器记录的是正在执行的虚拟机字节码指令的地址，当线程在执行的是 Native 方法（调用本地操作系统方法）时，该计数器的值为空。另外，该内存区域是唯一一个在 Java 虚拟机规范中么有规定任何 OOM（内存溢出：OutOfMemoryError）情况的区域。</p><p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>该区域也是线程私有的，它的生命周期也与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构。栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。 每一个方法从调用到方法执行完成，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。</p><p>在 Java 虚拟机规范中，对这个区域规定了两种异常情况：</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。</li><li>如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li></ul><p>1.只有在调用一个方法时，才为当前栈分配一个帧，然后将该帧压入栈</p><p>2.帧中存储了对应方法的局部数据，方法执行完，对应的帧则从栈中弹出，并把返回结果存储在调用方法的帧的操作数栈中</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。  方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。 </p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>Java Heap 是 Java 虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap 是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。</p><p>根据 Java 虚拟机规范的规定，Java 堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出 OutOfMemoryError 异常。</p><blockquote><p>堆和栈的区别</p><ul><li><p>功能不同</p><ul><li>栈内存用来存储局部变量和方法调用。</li></ul></li><li><p>而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</p></li><li><p>共享性不同</p><ul><li>栈内存是线程私有的。</li><li>堆内存是所有线程共有的。</li></ul></li><li><p>异常错误不同</p></li></ul><p>如果栈内存或者堆内存不足都会抛出异常。</p><ul><li>栈空间不足：java.lang.StackOverFlowError。</li><li>堆空间不足：java.lang.OutOfMemoryError。</li></ul><ul><li>空间大小</li></ul><p>栈的空间大小远远小于堆的。</p></blockquote><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区域又被称为“永久代”，但这仅仅对于 Sun HotSpot 来讲 。</p><p>它存储了每一个类的结构信息。例如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容，上面讲的是规范，在不同的虚拟机里面实现是不一样的的，最典型的就是永久代和元空间。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，它直接从操作系统中分配，因此不受 Java 堆大小的限制，但是会受到本机总内存的大小及处理器寻址空间的限制，因此它也可能导致 OutOfMemoryError 异常出现。在 JDK1.4 中新引入了 NIO 机制，它是一种基于通道与缓冲区的新 I/O 方式，可以直接从操作系统中分配直接内存，即在堆外分配内存，这样能在一些场景中提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 </p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用） </p><p> JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池 </p><h2 id="2-HotSpot虚拟机对象探秘"><a href="#2-HotSpot虚拟机对象探秘" class="headerlink" title="2.HotSpot虚拟机对象探秘"></a>2.HotSpot虚拟机对象探秘</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><h4 id="1-类加载检查"><a href="#1-类加载检查" class="headerlink" title="1.类加载检查"></a>1.类加载检查</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h4 id="2-分配内存"><a href="#2-分配内存" class="headerlink" title="2.分配内存"></a>2.分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><p> <strong>内存分配的两种方式</strong> ：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/12581a/cdn/images/distribute.png" alt></p><p> <strong>内存分配并发问题</strong> :</p><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的， 对象分配内存不是线程安全的，比如给对象A分配内存，还没来得及修改指针的指向， 另一个线程创建对象B也用了原来的指针，这样就会出问题的。 通常来讲，虚拟机采用两种方式来保证线程安全：</p><p>（1） 对分配内存空间的动作进行同步处理 </p><p> 实际上虚拟机采用CAS配上失败重试的方式保证更新指针操作的原子性 </p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li></ul><p>（2） 把内存分配的动作按照线程划分在不同的空间中进行 </p><p>即：每个线程在java堆中预分配一小块内存， 这一小块内存称作“本地线程分配缓冲”（Thread Local Allocation Buffer, TLAB） </p><ul><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配 </li></ul><h4 id="3-为对象的成员变量赋初始值"><a href="#3-为对象的成员变量赋初始值" class="headerlink" title="3.为对象的成员变量赋初始值"></a>3.为对象的成员变量赋初始值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="4-设置对象头"><a href="#4-设置对象头" class="headerlink" title="4.设置对象头"></a>4.设置对象头</h4><p>对象头是什么？对象头的作用是记录对象在运行过程中所需的数据。</p><p>初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="5-执行-init-方法"><a href="#5-执行-init-方法" class="headerlink" title="5.执行 init 方法"></a>5.执行 init 方法</h4><p>从上面对象的创建过程，我们可以了解到，在内存分配完成之后，所有成员变量的值都还只是零值。对于虚拟机来说，对象创建已经完毕，但是，对于java程序来说，对象的初始化才刚开始。成员变量的初始化工作交由<strong>init</strong>方法的来完成。编译器收集了成员变量上的赋值操作，实例初始化代码块的赋值操作，以及构造方法中的赋值操作，构成<strong>init</strong>方法，并执行，对象就得到了初始化。学习过java基础的人都知道，对象初始化的顺序为: 成员变量上的赋值–&gt;实例初始化块–&gt;构造方法。</p><p>init方法就解释了为什么是这个过程。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p> 在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。 </p><ul><li>实例数据</li></ul><p>实例数据存储的是成员变量的值，包括从父类继承下来的成员变量。</p><p>成员变量在内存中的顺序：相同宽度的字段会分配在一起，父类定义的变量会出现在子类之前， 默认情况下，子类中较窄的变量可能会被插入到父类变量的间隙中。反正就是不一定按定义的顺序来分配。</p><ul><li>对象头是什么？</li></ul><p>对象头的作用是记录对象在运行过程中所需的数据。</p><p>比如对象属于哪个类的实例、所属类的信息在方法区中的位置（类型指针）、对象的哈希码、对象的GC分代年龄等信息。这些信息就保存在对象头中（Object Header）</p><ul><li>对齐填充又是什么？</li></ul><p>对齐填充是用于确保对象的内存的总长度为8字节的整数倍。</p><p>为什么要是确保是8字节的整数倍呢？</p><p>因为hotspot要求对象起始地址为8字节的整数倍以便于自动内存管理， 换句话说，对象的总长度要为8字节的整数倍才能保证如此。 而又因为对象头正好是8字节（32位或64位）的整数倍，但是实例数据长度是任意的，因此需要对齐补充来确保整个对象总长度为8字节的整数倍。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>java程序需要通过引用来操作堆上的具体数据。 根据引用存放的地址类型的不同，对象有不同的访问方式</p><p>主要有两种访问方式： 使用句柄访问 和  使用直接指针访问</p><ol><li><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li></ol><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/12581a/cdn/images/%E5%8F%A5%E6%9F%84.png" alt></p><ol><li><strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</li></ol><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/12581a/cdn/images/zjzhi.png" alt></p><p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p><h2 id="3-类文件结构"><a href="#3-类文件结构" class="headerlink" title="3.类文件结构"></a>3.类文件结构</h2><h2 id="4-虚拟机加载机制"><a href="#4-虚拟机加载机制" class="headerlink" title="4.虚拟机加载机制"></a>4.虚拟机加载机制</h2><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。 </p><h4 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h4><p>类加载过程的第一步，主要完成下面3件事情：</p><ol><li><p>通过全类名获取定义此类的二进制字节流</p></li><li><p>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</p></li><li><p>在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口</p><p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。 </p></li></ol><h5 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h5><ul><li>启动类加载器：Bootstrap ClassLoader，跟上面相同。它负责加载存放在<code>JDK\jre\li</code>(JDK 代表 JDK 的安装目录，下同)下，或被<code>-Xbootclasspath</code>参数指定的路径中的，并且能被虚拟机识别的类库（如 rt.jar，所有的<code>java.*</code>开头的类均被 Bootstrap ClassLoader 加载）。启动类加载器是无法被 Java 程序直接引用的。</li><li>扩展类加载器：Extension ClassLoader，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>JDK\jre\lib\ext</code>目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库（如<code>javax.*</code>开头的类），开发者可以直接使用扩展类加载器。</li><li>应用程序类加载器：Application ClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader 来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载</li></ul><h5 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h5><h4 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求    ，并且不会危害虚拟机自身的安全。</p><ul><li>文件格式的验证：验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。</li><li>元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合 Java 语法规范的元数据信息。</li><li>字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</li><li>符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。</li></ul><h4 id="3-准备"><a href="#3-准备" class="headerlink" title="3.准备"></a>3.准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ol><li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>这里所设置的初始值”通常情况”下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 fianl 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111。</li><li><ul><li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li><li>对于同时被 static 和 final 修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被 final 修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li><li>对于引用数据类型 reference 来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</li><li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li></ul></li></ol><h4 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。 </p><h4 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h4><p>初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的 Java 程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器()方法的过程。 </p><h4 id="6-卸载"><a href="#6-卸载" class="headerlink" title="6.卸载"></a>6.卸载</h4><p>卸载类即该类的Class对象被GC。</p><p>卸载类需要满足3个要求:</p><ol><li>该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被GC</li></ol><p>所以，在JVM生命周期类，由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p><p>只要想通一点就好了，jdk自带的BootstrapClassLoader,PlatformClassLoader,AppClassLoader负责加载jdk提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p><h2 id="5-垃圾收集器"><a href="#5-垃圾收集器" class="headerlink" title="5.垃圾收集器"></a>5.垃圾收集器</h2><h4 id="堆的划分"><a href="#堆的划分" class="headerlink" title="堆的划分"></a>堆的划分</h4><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/12581a/cdn/images/hea.png" alt></p><p>​    虚拟机中的共划分为三个代：</p><p>​    年轻代（Young Generation）、年老代（Old    Generation）和持久代（Permanent  </p><p>​    Generation）。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系  </p><p>​    不大。年轻代和年老代的划分是对垃圾收集影响比较大的。</p><blockquote><p> <strong>在Java8中移除了永生代，取而代之是元空间(Metaspace)</strong> </p><ul><li>移除了永久代（PermGen），替换为元空间（Metaspace）</li><li>永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；</li><li>永久代中的 interned Strings 和 class static variables 转移到了 Java heap；</li><li>永久代参数 （PermSize MaxPermSize） -&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize）</li></ul></blockquote><p>MinorGc的过程（复制–&gt;清空–&gt;互换）</p><h2 id="6-堆参数调优"><a href="#6-堆参数调优" class="headerlink" title="6.堆参数调优"></a>6.堆参数调优</h2><p>元空间与永久代之间最大的区别：</p><p>永久带使用的是JVM的堆内存，但是Java8以后的元空间并不在虚拟机中而是使用本机物理内存。</p><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><p>1.引用计数法</p><p>2.复制算法</p><p>3.标记清除</p><p>4.标记压缩</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring概述</title>
      <link href="/posts/359.html"/>
      <url>/posts/359.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h1><h2 id="一、spring的IOC"><a href="#一、spring的IOC" class="headerlink" title="一、spring的IOC"></a>一、spring的IOC</h2><h3 id="1-springIOC原理"><a href="#1-springIOC原理" class="headerlink" title="1.springIOC原理"></a>1.springIOC原理</h3><pre><code class="java">&lt;bean id=&quot;helloWorld&quot; class=&quot;com.ioc.HelloWorld&quot;&gt;       &lt;property name=&quot;message&quot; value=&quot;Hello World!&quot;/&gt;&lt;/bean&gt;</code></pre><p>首先加载并解析上面的配置文件，获取标签中的id和class属性，根据class属性利用反射来创建类对象和设置类属性，最后将Bean注入到Bean容器中。</p><p><strong>什么是POJO，JavaBean？</strong></p><p>POJO：<br> 一个简单的Java类，这个类没有实现/继承任何特殊的java接口或者类，不遵循任何主要java模型，约定或者框架的java对象，在理想情况下，POJO不应该有注解。<br> JavaBean：</p><ul><li>JavaBean是可序列化的，实现了serializable接口</li><li>具有一个无参构造器</li><li>有按照命名规范的set和gett，is（可以用于访问布尔类型的属性）方法</li></ul><p><strong>ApplicationContext容器</strong></p><pre><code class="java">public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory,     HierarchicalBeanFactory,MessageSource, ApplicationEventPublisher,ResourcePatternResolver {</code></pre><p>ApplicationContext是一个接口，最常被使用的 ApplicationContext 接口实现： </p><ul><li><strong>FileSystemXmlApplicationContext</strong>：该容器从 XML 文件中加载已被定义的 bean。在这里，你需要提供给构造器 XML 文件的完整路径 </li></ul><ul><li><strong>ClassPathXmlApplicationContext</strong>：该容器从 XML 文件中加载已被定义的 bean。在这里，你不需要提供 XML 文件的完整路径，只需正确配置 CLASSPATH 环境变量即可，因为，容器会从 CLASSPATH 中搜索 bean 配置文件。</li><li><strong>WebXmlApplicationContext</strong>：该容器会在一个 web 应用程序的范围内加载在 XML 文件中已被定义的 bean。</li></ul><h3 id="2-springBean的生命周期"><a href="#2-springBean的生命周期" class="headerlink" title="2.springBean的生命周期"></a>2.springBean的生命周期</h3><ul><li>Bean容器找到配置文件中 Spring Bean 的定义。</li><li>Bean容器利用Java Reflection API创建一个Bean的实例。</li><li>如果涉及到一些属性值,利用set方法设置一些属性值。</li><li>如果Bean实现了BeanNameAware接口，调用setBeanName()方法，传入Bean的名字。</li><li>如果Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。</li><li>如果Bean实现了BeanFactoryAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。</li><li>与上面的类似，如果实现了其他*Aware接口，就调用相应的方法。</li><li>如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessBeforeInitialization()方法</li><li>如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。</li><li>如果Bean在配置文件中的定义包含init-method属性，执行指定的方法。</li><li>如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessAfterInitialization()方法</li><li>当要销毁Bean的时候，如果Bean实现了DisposableBean接口，执行destroy()方法。</li><li>当要销毁Bean的时候，如果Bean在配置文件中的定义包含destroy-method属性，执行指定的方法。</li></ul><p><strong>基于注解的配置</strong></p><ul><li><strong>@Required</strong> 注释应用于 bean 属性的 setter 方法，它表明受影响的 bean 属性在配置时必须放在 XML 配置文件中，否则容器就会抛出一个 BeanInitializationException 异常。 </li><li><strong>@Autowired</strong> 注释可以在 setter 方法中被用于自动连接 bean，在属性上面使用来除去setter方法</li><li><strong>@Resource</strong> ,如 @Resource(name=”userDao”) 在 private UserDao userdao上面</li><li><strong>@Controller</strong>对应表现层的Bean</li><li><strong>@Service</strong>对应的是业务层Bean ，如@Service(“user”)相当于<code>&lt;id=&quot;user&quot; class=&quot;...&quot;&gt;</code></li><li><strong>@Scope</strong>,如在类上加@Scope(value=”prototype”)注解表示多实例。 </li><li><strong>@Repository</strong>对应数据访问层Bean  </li></ul><h3 id="3-bean的作用域"><a href="#3-bean的作用域" class="headerlink" title="3.bean的作用域"></a>3.bean的作用域</h3><p>在 Spring 中，那些组成应用程序的主体及由 Spring IOC 容器所管理的对象，被称之为 bean。简单地讲，bean 就是由 IOC 容器初始化、装配及管理的对象，除此之外，bean 就与应用程序中的其他对象没有什么区别了。而 bean 的定义以及 bean 相互间的依赖关系将通过配置元数据来描述。 </p><table><thead><tr><th>类别</th><th>说明</th></tr></thead><tbody><tr><td>singleton</td><td>单例，是默认值。可以指定Bean节点的 <code>lazy-init=”true”</code> 来延迟初始化bean，这时候，只有在第一次获取bean时才会初始化bean，即第一次请求该bean时才初始化。</td></tr><tr><td>prototype</td><td>定义对应多个对象实例。 prototype 作用域的 bean 会导致在每次对该 bean 请求时都会创建一个新的 bean 实例。</td></tr><tr><td>request</td><td>每一次HTTP请求都会产生一个新的 bean，bean仅在当前HTTP request内有效。request只适用于Web程序，每一次 HTTP 请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效，当请求结束后，该对象的生命周期即告结束。</td></tr><tr><td>session</td><td>每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。session只适用于Web程序，session 作用域表示该针对每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</td></tr><tr><td>globalSession</td><td>在一个全局的HTTP Session中，一个bean定义对应一个实例。典型情况下，仅在使用portlet context的时候有效。该作用域仅在基于 web的Spring ApplicationContext情形下有效。</td></tr></tbody></table><h2 id="二、spring的AOP"><a href="#二、spring的AOP" class="headerlink" title="二、spring的AOP"></a>二、spring的AOP</h2><h3 id="1-原理概述"><a href="#1-原理概述" class="headerlink" title="1.原理概述"></a>1.原理概述</h3><p>动态代理的两类实现：Jdk动态代理与基于继承的代理，两类代理的实现：Jdk代理与Cglib代理。Jdk动态代理只能 基于接口进行动态代理。Cdlib基于继承实现来实现代理，无法对static、final类进行代理,无法对private、static方法进行代理。</p><pre><code class="java">public class JdkProxy implements InvocationHandler {    private BookImpl bookImpl;    public JdkProxy(BookImpl bookImpl) {        this.bookImpl = bookImpl;    }    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        System.out.println(&quot;proxy......&quot;);        Object book = null;        book = (BookImpl) method.invoke(bookImpl,args);        return book;    }}public class TestAop {    public static void main(String[] args) {        Book book = (Book) Proxy.newProxyInstance(TestAop.class.getClassLoader(),                new Class[]{Book.class},new JdkProxy(new BookImpl()));        book.add();    }//proxy......//add......    </code></pre><pre><code class="java">public class DemoMethodInterceptor implements MethodInterceptor {    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {        System.out.println(&quot;beforeCglib......&quot;);        Object book = null;        book = methodProxy.invokeSuper(o,objects);        System.out.println(&quot;beforeCglib......&quot;);        return book;    }}public class TestAop {    public static void main(String[] args) {        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(BookImpl.class);        enhancer.setCallback(new DemoMethodInterceptor());        Book book = (Book) enhancer.create();        book.add();    }//beforeCglib......//add......//beforeCglib......</code></pre><pre><code class="java">&lt;!--配置aop的操作--&gt;    &lt;aop:config&gt;        &lt;!--配置切入点 --&gt;        &lt;aop:pointcut expression=&quot;execution(* cn.itcast.aspectj.Book.*(..))&quot; id=&quot;pointcut1&quot;/&gt;        &lt;!--配置切面--&gt;        &lt;aop:aspect ref=&quot;myBook&quot;&gt;            &lt;!--配置增强的类型--&gt;            &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;</code></pre><h3 id="2-表达式"><a href="#2-表达式" class="headerlink" title="2.表达式"></a>2.表达式</h3><p><strong>1.within表达式</strong></p><pre><code class="java">@Aspect@Componentpublic class YourBook {    @Pointcut(&quot;within(com.spring.aop.Book)&quot;)    public void matchType(){}    @Before(&quot;matchType()&quot;)    public void before(){        System.out.println(&quot;yourbefore......&quot;);    }}</code></pre><p><strong>2.对象表达式</strong></p><pre><code class="java">@Aspect@Componentpublic class YourBook {    //Book是一个接口，会拦截所有实现了这个接口的类    @Pointcut(&quot;this(com.spring.aop.Book)&quot;)    public void matchType(){}    ......}//@Pointcut(&quot;target(com.spring.aop.Book)&quot;)//@Pointcut(&quot;Bean(BookImpl)&quot;)</code></pre><p><strong>3.execution表达式，execution(&lt;访问修饰符&gt;&lt;返回类型&gt;&lt;方法名(&lt;参数&gt;)&lt;异常&gt;)</strong></p><pre><code class="java">@Aspect@Componentpublic class YourBook {    @Pointcut(&quot;execution(* cn.itcast.aspectj.Book.*(..))&quot;)    public void matchType(){}    ......}//@Before(value=&quot;execution(* cn.itcast.aspectj.Book.*(..))&quot;)</code></pre><h2 id="三、springMVC"><a href="#三、springMVC" class="headerlink" title="三、springMVC"></a>三、springMVC</h2><h3 id="1-架构原理分析"><a href="#1-架构原理分析" class="headerlink" title="1.架构原理分析"></a>1.架构原理分析</h3><ul><li><p>发起请求到前端控制器（DispatcherServlet）</p></li><li><p>前端控制器请求HandlerMapping查找Handler，可以根据xml配置、注解方式查找</p></li><li><p>处理器映射器HandlerMapping向前端控制器返回Handler</p></li><li><p>前端控制器调用处理器适配器去执行Handler,Handler执行完成给适配器返回ModeAndView</p></li><li><p>处理器适配器向前端控制器返回ModeAndView。ModeAndView是springMVC框架对象的一个底层的对象，包括Model和view。</p></li><li><p>前端控制器请求视图解析器去进行视图的解析，根据逻辑视图解析成真正的视图    （jsp）</p></li><li><p>视图解析器向前端控制器返回view,前端控制器进行视图的渲染。视图渲染将模型数据（在ModelAndView对象中）填充到request域中。</p></li></ul><h3 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.配置文件"></a>2.配置文件</h3><pre><code class="properties">&lt;!--在web.xml中配置前端控制器--&gt;&lt;servlet&gt;          &lt;servlet-name&gt;springmvctest&lt;/servlet-name&gt;          &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;             &lt;init-param&gt;              &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;              &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;              &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;      &lt;servlet-mapping&gt;          &lt;servlet-name&gt;springmvctest&lt;/servlet-name&gt;          &lt;url-pattern&gt;/&lt;/url-pattern&gt;      &lt;/servlet-mapping&gt;  </code></pre><pre><code class="properties">&lt;!--视图解析器--&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;             &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;             &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;</code></pre><h3 id="3-SpringMVC常见注解"><a href="#3-SpringMVC常见注解" class="headerlink" title="3.SpringMVC常见注解"></a>3.SpringMVC常见注解</h3><ul><li><strong>@RequestMapping</strong></li></ul><p>是一个用来处理请求地址映射的注解,适用于类、方法。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><ul><li><strong>@PathVariable</strong></li></ul><p>用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数 </p><pre><code class="java">@RequestMapping(&quot;/delete/{id}&quot;)public String deleteTest(@PathVariable(value=&quot;id&quot;) Integer id){}</code></pre><ul><li><strong>@RequestParam</strong></li></ul><p>用于将请求参数区数据映射到功能处理方法的参数上 </p><p> value/name: 两个属性都指代参数名字，即入参的请求参数名字(通常表单name属性)<br> required: 是否必须，默认是true，表示请求中一定要有相应的参数，否则将抛出异常<br> defaultValue: 默认值，表示如果请求中没有同名参数时的默认值，设置该参数时，自动将required设为false</p><pre><code class="java">@RequestMapping(&quot;/test&quot;)public String deleteTest(@RequestParam(value=&quot;username&quot;) String user,@RequestParam(value=&quot;password&quot;,required=false,defaultValue=&quot;0&quot;) Integer passWord){}</code></pre><ul><li><p><strong>@CookieValue</strong></p><p>可以把Request header中关于cookie的值绑定到方法的参数上 </p></li></ul><pre><code class="java">public String index(@CookieValue(&quot;JSESSIONID&quot;) String cookie){}</code></pre><ul><li><strong>@SessionAttributes</strong></li></ul><p>只能作用在类上，作用是将指定的Model中的键值对添加至session中，方便在下一次请求中使用。 </p><pre><code class="java">@Controller@RequestMapping(&quot;/testSessionAttribute&quot;)@SessionAttributes(value = {&quot;user&quot;},types={String.class})public class TestSessionAttributeController {    @RequestMapping(&quot;/testHandler&quot;)    public String testHandler(Model model, String age, String name){       User user = new User(age,name);       model.addAttribute(&quot;user&quot;,user);        model.addAttribute(&quot;age&quot;,age);       return &quot;result&quot;;    }}</code></pre><p><strong>@modelAttribute</strong></p><p>应用在方法上: 被<code>@ModelAttribute</code>注解的方法会在<code>Controller</code>每个方法执行之前都执行，因此对于一个<code>Controller</code>中包含多个URL的时候，要谨慎使用。 </p><h2 id="四、SpringBoot"><a href="#四、SpringBoot" class="headerlink" title="四、SpringBoot"></a>四、SpringBoot</h2><h3 id="1-Springboot的优点"><a href="#1-Springboot的优点" class="headerlink" title="1.Springboot的优点"></a>1.Springboot的优点</h3><p>Spring Boot遵循“固执己见的默认配置”，以减少开发工作（默认配置可以修改）。 Spring Boot 项目所需的开发或工程时间明显减少，通常会提高整体生产力。 </p><h3 id="2-SpringBoot配置"><a href="#2-SpringBoot配置" class="headerlink" title="2.SpringBoot配置"></a>2.SpringBoot配置</h3><p>通过<code>@Value</code>来读取配置信息，还可以通过<code>@ConfigurationProperties</code>读取并与 bean 绑定。它们之间的比较：</p><table><thead><tr><th></th><th>@ConfigurationProperties</th><th>@value</th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件中的属性</td><td>一个个指定</td></tr><tr><td>松散绑定（松散语法）</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303数据校验</td><td>支持</td><td>不支持</td></tr><tr><td>复杂类型封装</td><td>支持</td><td>不支持</td></tr></tbody></table><p>使用原则：在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；如果专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； </p><pre><code class="java">/** 配置文件中的属性与类对应的属性绑定,默认从全局配置文件中获取值*/@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person {    //@Value(&quot;${person.username}&quot;)    private String username;    private Integer password;//yml配置文件person:    username: zhangsan    password: 123456</code></pre><pre><code class="xml">//pom文件配置可以有提示&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><pre><code>yml语法：k:v：字面直接写    字符串默认不加上单引号或双引号；    &quot;&quot;:双引号，不会转义字符串里的特殊字符；&#39;&#39;:会转义特殊字符，特殊字符最终只是一个普通的字符串数据对象属性直接写，还有一种行内写法，user: {name: zhangsan,age: 13}数组、list的写法：行内写法：zoo: [cat,dog,pig]zoo: - cat - dog - pigmap的写法：maps: {k1: v1,k2: v2}</code></pre><p><strong>@PropertySource</strong>与<strong>@ImportResource</strong></p><p>可以将元数据的配置内容单独的建一个文件，如<code>person.properties</code>文件</p><pre><code class="java">/** @PropertySource,加载指定的配置文件*/@Component@PropertySource(value=&quot;{classpath:person.properties}&quot;)public class Person {    private String username;    private Integer password;</code></pre><pre><code class="java">/**@ImportResource,导入自己写的spring的配置文件*&lt;id=&quot;&quot; class=&quot;...&quot;&gt;会被注入*/@ImportResource(locations = {&quot;classpath:bean.xml&quot;})@SpringBootApplicationpublic class DemoApplication {}</code></pre><p>springBoot推荐给容器中添加组件的方式，推荐使用全注解的方式</p><p><strong>@Conﬁguration</strong>注解：指明当前类是一个配置类，可以替代之前的Spring配置文件</p><pre><code class="java">@Configurationpublic class MyConfig {    @Bean    public User provideUser(){        return new User();    }}</code></pre><p><strong>Profile</strong>是Spring对不同的环境提供不同功能的支持，可以通过激活、指定参数快速的切换环境</p><p>（1）多profile文件形式：application-{profile}.properties/yml</p><p>spring 的配置文件有两种形式 一种是properties 文件 ，一种是 yaml 文件 ，不管哪一种都可以用文件命名的形式区分不同环境的配置 。如：开发环境 ：application-dev.properties，生产环境：application-prod.properties<br>然后在 application.properties 文件中激活，当前的环境 ：spring.profiles.active = dev ,激活开发环境 </p><p>（2）多profile文档块模式： 这个只针对yml文件格式 ，方便写在一个文件中 ，使用<code>---</code>分隔</p><p>（3）命令行激活：–spring.profiles.active=dev</p><p><strong>SpringBoot配置文件的加载位置和优先级</strong>：</p><p>SpringBoot启动会扫描以下位置的application.yml或者 application.properties文件作为SpringBoot的默认配置文件。</p><p>-file:./config/   </p><p>-file:./</p><p>-classpath:/config/</p><p>-classpath:/</p><p>即根目录下的config目录下，然后是 根目录下，然后是classpath路径下的config目录下，最后是classpath路径下。</p><p>优先级由高到低，高优先级的配置会覆盖低优先级的配置。</p><p><strong>自动配置的原理</strong></p><p>Spring Boot的启动类上有一个<code>@SpringBootApplication</code>注解，这个注解是Spring Boot项目必不可少的注解,它是一个复合注解或派生注解，在<code>@SpringBootApplication</code>中有一个注解<code>@EnableAutoConfiguration</code>，这个注解开启了自动配置的功能。</p><p><code>@EnableAutoConfiguration</code>这个注解也是一个派生注解，其中的关键功能由@Import提供，其导入的<code>AutoConfigurationImportSelector</code>的</p><pre><code>List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</code></pre><pre><code>List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),      getBeanClassLoader());</code></pre><p><code>SpringFactoriesLoader.loadFactoryNames()</code>扫描所有具有META-INF/spring.factories的jar包。 这个<strong>spring.factories</strong>文件也是一组一组的key=value的形式，其中一个key是EnableAutoConfiguration类的全类名，而它的value是一个xxxxAutoConfiguration的类名的列表，这些类名以逗号分隔。</p><pre><code class="properties"># Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</code></pre><p>每一个这样的xxxAutoConfiguration类都是容器的一个组件，都加入到容器中，用它们来做自动配置。</p><p>自动配置信息有了，那么自动配置还差什么呢？ </p><p> <code>@Conditional</code> 注解。 当这个注解所指定的条件成立，才给容器中添加组件，配置里面的内容才生效。</p><p> 以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理 </p><pre><code class="java">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@Configuration(proxyBeanMethods=false)//启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；@EnableConfigurationProperties(HttpProperties.class)    [    @ConfigurationProperties(prefix = &quot;spring.http&quot;)    public class HttpProperties {    ]//Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，//整个配置类里面的配置就会生效；判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnWebApplication(type=ConditionalOnWebApplication.Type.SERVLET)//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；        @ConditionalOnClass(CharacterEncodingFilter.class)//判断配置文件中是否存在某个配置spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；@ConditionalOnProperty(prefix = &quot;spring.http.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing = true)</code></pre><p>可以通过在yum文件中<code>debug = true</code>属性，来让控制台打印自动配置报告。</p><h3 id="3-日志"><a href="#3-日志" class="headerlink" title="3.日志"></a>3.日志</h3><p>日志门面：SLFJ(Simple Logging Facade for Java)</p><p>日志实现：Log4j、Logback</p><p>可以直接调用日志抽象层里面的方法</p><pre><code class="java">import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld {  public static void main(String[] args) {    Logger logger = LoggerFactory.getLogger(HelloWorld.class);    logger.info(&quot;Hello World&quot;);  }}</code></pre><p>如果想把其它的框架转换成SLF4J,先将系统中其他框架排除出去，用中间包替换原有的日志框架，导入slf4j其他实现。引入其他框架时，只需要把这个框架依赖的日志框架排除掉，SpringBoot能自动适配所有的框架。</p><p>SpringBoot默认配置</p><pre><code class="java">//日志的级别//由低到高，可以调整输出的日志级别，默认使用info级别logger.trace(&quot;trace日志&quot;);logger.debug(&quot;debug日志&quot;);logger.info(&quot;info日志&quot;);logger.warn(&quot;warn日志&quot;);logger.error(&quot;errors&quot;);</code></pre><pre><code class="properties">logging.level.com = tracelogging.file.path = D:/springboot.log</code></pre><p>指定配置，给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用其他默认配置的了。</p><p>定义自己的日志配置文件</p><table><thead><tr><th align="left">Logging System</th><th align="left">Customization</th></tr></thead><tbody><tr><td align="left">Logback</td><td align="left"><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code>, or <code>logback.groovy</code></td></tr><tr><td align="left">Log4j2</td><td align="left"><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td align="left">JDK (Java Util Logging)</td><td align="left"><code>logging.properties</code></td></tr></tbody></table><p><code>logback.xml</code>:直接就被日志框架识别了</p><p><code>logback-spring.xml</code>:可以指定在某个环境下生效</p><pre><code class="properties">&lt;springProfile name=&quot;dev&quot;&gt;    &lt;!-- configuration to be enabled when the &quot;dev&quot; or &quot;staging&quot; profiles are active --&gt;&lt;/springProfile&gt;</code></pre><h2 id="五-Spring-Data"><a href="#五-Spring-Data" class="headerlink" title="五.Spring Data"></a>五.Spring Data</h2><p>Spring Data是Spring的一个子项目，用于简化数据库的访问，支持NoSQL和关系型数据库。其主要的目标是使数据库的访问变得方便快捷。</p><p>JPA Spring Data致力于减少数据库访问层的开发量，开发者唯一要做的只是声明持久层的接口。</p><p>（1）编写实体类和数据表映射</p><pre><code class="java">@Entity//表明是一个实体类，和数据表映射的类@Table(name=&quot;book&quot;)//指定和哪个数据表对应；如果省略，默认表名就是bookpublic class Book {    @Id //标明主键    @GeneratedValue(strategy = GenerationType.AUTO) //自增主键    private Integer id;    @Column(name = &quot;last_Name&quot;,length = 20)//和数据表对应的列，省略默认name为表名    private String name;</code></pre><p>（2）编写Dao接口来操作实体类对应的数据表</p><pre><code class="java">public interface BookRepository extends JpaRepository&lt;Book,Integer&gt;{}</code></pre><p>（3) 编写Controller层</p><pre><code class="java">public class BookController {    @Autowired    BookRepository bookRepository;    @GetMapping(&quot;/book&quot;)    public List&lt;Book&gt; getBooks(){        List&lt;Book&gt; all = bookRepository.findAll();        return all;    }</code></pre><p>(4)application中的配置</p><pre><code class="properties">spring:  datasource:    username: root    password: 123456    url: jdbc:mysql://localhost:3306/test?serverTimezone=UTC    jpa:    hibernate:      ddl-auto: update #更新或者创建数据表结构</code></pre><p><code>Repository&lt;T,ID&gt;</code>，Repository是一个空接口，即是一个标记接口，若我们定义的接口继承了Repository,则该接口会被IOC容器识别为一个Repository Bean。</p><pre><code class="java">//还可以通过注解实现@RepositoryDefinition(domainClass = Book.class,idClass = Integer.class)public interface BookRepository {}</code></pre><p>Repository查询方法定义规范：</p><p>按照Spring Data规范，查询方法以<code>find</code>,<code>read</code>,<code>get</code>开头。涉及条件查询时，条件的属性用条件关键字连接。</p><pre><code class="java">//WHERE lastName LIKE ?% AND id &lt; ?List&lt;Person&gt; getByLastNameStartingWithAndIdLessThan(String lastName, Integer id)</code></pre><p>上面的这个不好使，我们来使用<code>@Query</code>注解灵活查询。</p><pre><code class="java">//传递参数的方式：使用占位符、命名参数@Query(&quot;SELECT b FROM Book b WHERE b.id&gt;?1 And b.name Like ?2%&quot;)List&lt;Book&gt; getBookByIdAndName(Integer id,String name);@Query(&quot;update Book b set b.author=:author where b.id=:id&quot;)void updateBook(@Param(&quot;id&quot;) Integer id,@Param(&quot;author&quot;) String author);//nativeQuery = true使用原生的SQL查询@Query(value=&quot;select count(id) from book&quot;,nativeQuery = true)long getTotalcount();</code></pre><p>可以通过自定义JPOL完成UPDATE和DELETE操作，JPQL不支持INSERT</p><pre><code class="java">//使用时在Controller方法上要加一个@Transactional注解@Modifying@Query(&quot;update Book b set b.author=:author where b.id=:id&quot;)void updateBook(@Param(&quot;id&quot;) Integer id,@Param(&quot;author&quot;) String author);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/posts/6a89.html"/>
      <url>/posts/6a89.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis知识点总结"><a href="#Redis知识点总结" class="headerlink" title="Redis知识点总结"></a>Redis知识点总结</h1><h2 id="一-noSql概述"><a href="#一-noSql概述" class="headerlink" title="一.noSql概述"></a>一.noSql概述</h2><p>Not Only SQL,意为“不仅仅是SQL”</p><p>分库分表+水平拆分+MySQL集群</p><p>1.在Memcached的高速缓存，MySQL的主从复制，读写分离的基础上，这时MySQL主库的写压力出现瓶颈，而数据量的猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。同时，使用分库分表来缓解写的压力和数据增长的扩展问题。</p><p>2.NoSQL易扩展、大数据量高性能、多样灵活的数据类型。没有声明性查询语言，没有预定的模式，键值对存储，最终一致性，而非ACID属性。</p><p>3.大数据时代的3v:海量、多样、实时，互联网需求的3高：高并发、高可扩、高性能。</p><p>4.NoSQL数据模型简介：聚合模型：KV键值、Bson、列族、图形</p><p>5.NoSql数据库的四大分类：</p><p>​    KV键值对(Redis)、文档型数据库（MongDB）、列存储数据库（HBase）、图关系数据库</p><p>6.在分布式数据库中CAP原理CAP+BASE</p><p>7.传统的ACID是什么？</p><ul><li>A (Atomicity) 原子性</li></ul><p>原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。</p><p>比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。</p><ul><li>C (Consistency) 一致性</li></ul><p>一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。</p><p>例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。</p><ul><li>I (Isolation) 独立性</li></ul><p>所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。</p><p>比如现在有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。</p><ul><li>D (Durability) 持久性</li></ul><p>持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</p><p><strong>CAP原理:</strong>强一致性、可用性、分区容错性。（三选二）</p><ul><li>Consistency: 一致性指的是所有节点都能在同一时间返回同一份最新的数据副本</li><li>Availability: 可用性指的是每次请求都能够返回非错误的响应</li><li>Partition tolerance: 分区容错性指的是服务器间的通信即使在一定时间内无法保持畅通也不会影响系统继续运行</li></ul><p>7.分布式与集群</p><p>分布式：不同的多台服务器上面部署不同的服务模块（工程），它们之间通过Rpc/Rmi之间通信和调用，对外提供服务和组内协作。</p><p>集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供访问和服务。</p><h2 id="二、Redis"><a href="#二、Redis" class="headerlink" title="二、Redis"></a>二、Redis</h2><p><a href="https://redis.io/" target="_blank" rel="noopener">redis官网</a></p><p>redis（远程字典服务器）： Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。 </p><p>默认16个数据库，初始默认使用零号库，<code>select</code>命令切换库，<code>dbsize</code>查看当前数据库key的数量。<code>keys *</code></p><p>查看具体的key。<code>keys k?</code>可以查找以k开头的key。<code>flushdb</code>删除当前库所有的，<code>flushall</code>删除所有库的。</p><p><strong>特点：</strong></p><ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><p><strong>能干嘛：</strong></p><ul><li>内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务。</li><li>取最新n个数据的操作：如可以将最新的10条评论的ID放在redis的List集合中。</li><li>模拟类似于HttpSession这种需要设定过期时间的功能。</li><li>发布、订阅消息系统</li><li>定时器、计数器</li></ul><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>解压安装包<code>tar -zxvf redis-4.0.9.tar.gz</code>，进入目录，在目录下执行<code>make install</code>,使用<code>cd /usr/local/bin</code>命令可以查看redis安装的位置。</p><p>下载解压安装后修改在redis.conf中修改daemonize为yes</p><p><code>redis-server myredis/redis.conf</code></p><p><code>redis-cli -p 6379</code></p><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><ul><li>String</li></ul><p>string 是 redis 最基本的类型，一个 key 对应一个 value。</p><p>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</p><p>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p><pre><code>redis 127.0.0.1:6379&gt; set k1 v1OKredis 127.0.0.1:6379&gt; get k1&quot;v1&quot;</code></pre><ul><li>Hash</li></ul><p>Redis hash 是一个键值(key=&gt;value)对集合。</p><p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p><pre><code>redis 127.0.0.1:6379&gt; HMSET country China BeiJin England London&quot;OK&quot;redis 127.0.0.1:6379&gt; HGET country China&quot;GeiJin&quot;redis 127.0.0.1:6379&gt; HGET  country England&quot;London&quot;</code></pre><ul><li>list</li></ul><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 </p><pre><code>redis 127.0.0.1:6379&gt; lpush runoob redis(integer) 1redis 127.0.0.1:6379&gt; lpush runoob mongodb(integer) 2redis 127.0.0.1:6379&gt; lpush runoob rabitmq(integer) 3redis 127.0.0.1:6379&gt; lrange runoob 0 101) &quot;rabitmq&quot;2) &quot;mongodb&quot;3) &quot;redis</code></pre><ul><li>Set(集合)</li></ul><p>Redis 的 Set 是 string 类型的无序集合。</p><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)</p><pre><code>sadd key member</code></pre><ul><li>zset(sorted set：有序集合)</li></ul><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>zset的成员是唯一的,但分数(score)却可以重复。</p><pre><code>zadd key score member </code></pre><h3 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h3><p><strong>RDB</strong>: 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存中。 即在指定目录下生成一个dump.rdb文件，Redis 重启会通过加载dump.rdb文件恢复数据。 </p><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化进程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能，如果需要大规模的数据恢复，且对于数据恢复的完整性不是非常敏感，那么RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p><p>触发RDB快照，<code>save 秒钟 写操作次数</code>， 满足条件就将内存中的数据同步到硬盘中。官方出厂配置默认是 900秒内有1个更改，300秒内有10个更改以及60秒内有10000个更改，则将内存中的数据快照写入磁盘。 <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/12581a/cdn/images/re3.PNG" alt></p><p><code>stop-writes-on-bgsave-error</code>:如果配置成no,表示你不在乎数据不一致或者有其他的手段发现和控制。</p><p><code>rdbcompression</code> :对于存储到磁盘中的快照，可以设置是否进行压缩。</p><p><code>rdbchecksum</code>:在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/12581a/cdn/images/re2.PNG" alt></p><ul><li><strong>RDB 的优缺点</strong></li></ul><p>优点：<br>1 适合大规模的数据恢复。<br>2 如果业务对数据完整性和一致性要求不高，RDB是很好的选择。</p><p>缺点：<br>1 数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。<br>2 备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。所以Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。</p><p><strong>AOF</strong>: 以日志形式记录每个写操作，将Redis执行过的所有写操作记录下来，只许追加文件但不可以改写文件，redis重启的话就根据日志文件的内容将写的指令从前到后执行一次以完成数据的恢复工作。</p><p>redis 默认关闭，开启需要手动把no改为yes </p><pre><code class="java">appendonly yes</code></pre><p>指定本地数据库文件名，默认值为 appendonly.aof。假如<code>appendonly.aof</code>文件损坏，可以使用<code>redis-check-aof --fix appendonly.aof</code>命令修复。</p><pre><code>appendfilename &quot;appendonly.aof&quot;</code></pre><p><code>always</code>:同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据的完整性较好。</p><p><code>everysec</code>:出厂默认推荐，异步操作，每秒记录，如果一秒内宕机，有数据丢失。</p><p><code>no</code>:不同步</p><pre><code class="java"># appendfsync alwaysappendfsync everysec# appendfsync no</code></pre><ul><li><strong>AOF的重写机制</strong></li></ul><p>AOF采用文件追加的方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会对AOF文件的内容压缩。只保留可以恢复数据的最小指令集，可以使用命令bgrewriteaof </p><p>重写原理： Redis 会fork出一条新进程，读取内存中的数据，并重新写到一个临时文件中。并没有读取旧文件，最后替换旧的aof文件。 </p><p>触发机制：当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。这里的“一倍”和“64M” 可以通过配置文件修改。 </p><pre><code>//配置重写触发机制auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb</code></pre><ul><li><strong>AOF 的优缺点</strong></li></ul><p>优点：数据的完整性和一致性更高<br>缺点：因为AOF记录的内容多，文件会越来越大，数据恢复也会越来越慢。</p><h5 id="Redis的事务"><a href="#Redis的事务" class="headerlink" title="Redis的事务"></a>Redis的事务</h5><p>可以一次执行多个命令，本质是一组命令的集合。它能在一个队列中，一次性、顺序性、排他性的执行一系列命令。</p><p>一个事务从开始到执行会经历以下三个阶段：开始事务、命令入队、执行事务。</p><ul><li><strong>redis事务的相关命令</strong></li></ul><table><thead><tr><th align="center">序号</th><th>命令及描述</th></tr></thead><tbody><tr><td align="center">1</td><td><a href="https://www.runoob.com/redis/transactions-discard.html" target="_blank" rel="noopener">DISCARD</a> 取消事务，放弃执行事务块内的所有命令。</td></tr><tr><td align="center">2</td><td><a href="https://www.runoob.com/redis/transactions-exec.html" target="_blank" rel="noopener">EXEC</a> 执行所有事务块内的命令。</td></tr><tr><td align="center">3</td><td><a href="https://www.runoob.com/redis/transactions-multi.html" target="_blank" rel="noopener">MULTI</a> 标记一个事务块的开始。</td></tr><tr><td align="center">4</td><td><a href="https://www.runoob.com/redis/transactions-unwatch.html" target="_blank" rel="noopener">UNWATCH</a> 取消 WATCH 命令对所有 key 的监视。</td></tr><tr><td align="center">5</td><td><a href="https://www.runoob.com/redis/transactions-watch.html" target="_blank" rel="noopener">WATCH key [key …]</a> 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</td></tr></tbody></table><ul><li><strong>watch监控</strong></li></ul><p>乐观锁、悲观锁、CAS(Check and Set)</p><p>watch指令，类似于乐观锁，事务提交时，如果key的值已被别的客户端改变，整个事务队列都不会被执行。</p><h5 id="Redis的发布订阅"><a href="#Redis的发布订阅" class="headerlink" title="Redis的发布订阅"></a>Redis的发布订阅</h5><p>Redis 发布订阅(pub/sub)是进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p><h5 id="Redis的复制（Master-Slave）"><a href="#Redis的复制（Master-Slave）" class="headerlink" title="Redis的复制（Master/Slave）"></a>Redis的复制（Master/Slave）</h5><p>就是我们所说的主从复制，主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主,slave以读为主。主要的作用是读写分离和容灾恢复。</p><p>1.从库配置：<code>slaveof 主库IP 主库端口</code>，每次与master断开后，都需要重新连接</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/12581a/cdn/images/re1.PNG" alt></p><pre><code class="java">//从机6380127.0.0.1:6380&gt;slaveof 127.0.0.1 6379OK</code></pre><p>当主机写入东西如<code>set k1 v1</code>后，从机不能够写入东西，如<code>set k1 v11</code>这样的命令会报错。</p><p>假如主机死了，从机可以使用命令<code>slaveof no one</code> 成为主机。</p><p>2.哨兵模式：能够从后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p><p>在myredis下面新建一个sentinel.conf文件，文件内容为:</p><pre><code class="java">sentinel monitor host6379 127.0.0.1 6379 1</code></pre><p>上面的最后一个数字1，表示主机挂掉后salve投票看让谁接替成为主机。</p><p>启动哨兵<code>redis-sentinel /myredis/sentinel.conf</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>J2EE基础知识回顾</title>
      <link href="/posts/8fcd.html"/>
      <url>/posts/8fcd.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Servlet总结"><a href="#1-Servlet总结" class="headerlink" title="1.Servlet总结"></a>1.Servlet总结</h3><ol><li><p>Servlet是javaWeb的三大组件之一，它属于动态资源。Servlet的作用是请求处理，服务器会把接收到的请求交给Servlet来处理，在Servlet中通常需要接收请求数据、处理请求，完成响应。在Java Web程序中，<strong>Servlet</strong>主要负责接收用户请求 <code>HttpServletRequest</code>,在<code>doGet()</code>,<code>doPost()</code>中做相应的处理，并将回应<code>HttpServletResponse</code>反馈给用户。<strong>Servlet</strong> 可以设置初始化参数，供Servlet内部使用。一个Servlet类只会有一个实例，在它初始化时调用<code>init()</code>方法，销毁时调用<code>destroy()</code>方法<strong>。</strong>Servlet需要在web.xml中配置（MyEclipse中创建Servlet会自动配置），<strong>一个Servlet可以设置多个URL访问</strong>。<strong>Servlet不是线程安全</strong>，因此要谨慎使用类变量。</p></li><li><p>Servlet中的大多数方法不由我们来调用，对象也不由我们来创建，而是由Tomcat来调用和创建。</p></li><li><p>特性：线程不安全，一个类只有一个对象，当然可能存在多个Servlet类。</p></li></ol><h4 id="Servlet接口中的方法"><a href="#Servlet接口中的方法" class="headerlink" title="Servlet接口中的方法"></a>Servlet接口中的方法</h4><p><strong>生命周期：</strong> <strong>Web容器加载Servlet并将其实例化后，Servlet生命周期开始</strong>，容器运行其<strong>init()方法</strong>进行Servlet的初始化；请求到达时调用Servlet的<strong>service()方法</strong>，service()方法会根据需要调用与请求对应的<strong>doGet或doPost</strong>等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<strong>destroy()方法</strong>。<strong>init方法和destroy方法只会执行一次，service方法客户端每次请求Servlet都会执行</strong>。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。 </p><pre><code class="java">public void destroy(){} //在Servlet被销毁之前调用，只执行一次 public void init(ServletConfig servletConfig) throws ServletException {}//在Servlet对象创建之后执行，并且只执行一次public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException {} //会被调用多次，每次处理请求都在调用这个方法java.lang.String getServletInfo()ServletConfig getServletConfig()</code></pre><h4 id="ServletConfig接口"><a href="#ServletConfig接口" class="headerlink" title="ServletConfig接口"></a>ServletConfig接口</h4><pre><code class="java">String getInitParameter(String name)//通过名称获取指定初始化参数的值Enumeration&lt;String&gt;    getInitParameterNames()//获取所有初始化参数的名称ServletContext getServletContext()//获取Servlet上下文String getServletName()//获取所有初始化参数的名称</code></pre><p>如何让浏览器访问访问Servlet，在Web.xml中配置Servlet</p><p><url-pattern>是<servlet-mapping>的子元素，用来指定servlet的访问路径，即url。它必须是以“/”开头。中间可以加通配符，如/servlet/<em>（路径匹配）、/*、</em>.do（扩展名匹配）</servlet-mapping></url-pattern></p><pre><code class="java">&lt;servlet&gt;    &lt;servlet-name&gt;xxx&lt;/servlet-name&gt;    &lt;servlet-class&gt;cn.web.servlet.Aservlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;xxx&lt;/servlet-name&gt;    &lt;url-pattern&gt;/Aservlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><pre><code class="java">public class Aservlet extends HttpServlet {    public void doGet(HttpServletRequest req, HttpServletResponse resp)            throws ServletException, IOException {        System.out.println(&quot;doGet&quot;);    }}</code></pre><p>然后在浏览器中访问即可！</p><p><code>http://localhost:8080/项目名称/Aservlet</code></p><h4 id="servletContext接口"><a href="#servletContext接口" class="headerlink" title="servletContext接口"></a>servletContext接口</h4><p>一个项目只有一个servletContext对象，我们可以在N多个Servlet中获取这唯一的对象，使用它可以给多个servlet传递数据。servletContext对象的作用是在整个Web应用的动态资源之间共享数据！例如在Aservlet中向ServletContext对象中保存一个值，然后在Bservlet中就可以获取这个值，这就是共享数据了。</p><p>servletContext是javaWeb四大域对象之一。所有域对象都有存取数据的功能，因为域对象内部有一个Map,用来存储数据。<code>PageContext</code>、<code>ServletRequest</code>、<code>HttpSession</code>、<code>ServletContext</code></p><pre><code class="java">public class Aservlet extends HttpServlet {    public void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {            ServletContext application = this.getServletContext();            application.setAttribute(&quot;name&quot;,&quot;zhangsan&quot;);    }}</code></pre><p>请求响应的流程：创建servlet对象，把请求数据封装到request中，创建response对象，调用Servlet的service()方法传递这两个参数。在servlet.service方法中使用request获取请求数据，使用response完成响应。</p><h4 id="HttpServletResponse接口"><a href="#HttpServletResponse接口" class="headerlink" title="HttpServletResponse接口"></a>HttpServletResponse接口</h4><p>5秒后自动跳转</p><p><code>response.setHeader(&quot;Refresh&quot;,&quot;5;URL=www.baidu.com&quot;);</code></p><p>重定向</p><p><code>response.setHeader(&quot;Location&quot;,&quot;www.baidu.com&quot;);response.setStatus(302);</code></p><p>快捷的重定向方法</p><p><code>response.sendRedirect(&quot;www.baidu.com&quot;);</code></p><h4 id="get与post请求"><a href="#get与post请求" class="headerlink" title="get与post请求"></a>get与post请求</h4><p> 可以把 get 和 post 当作两个不同的行为，两者并没有什么本质区别，底层都是 TCP 连接。 get请求用来从服务器上获得资源，而post是用来向服务器提交数据。比如你要获取人员列表可以用 get 请求，你需要创建一个人员可以用 post 。这也是 Restful API 最基本的一个要求。 </p><p>什么情况下调用doGet()和doPost()？Form标签里的method的属性为get时调用doGet()，为post时调用doPost()。 </p><h4 id="转发-Forward-和重定向-Redirect-的区别"><a href="#转发-Forward-和重定向-Redirect-的区别" class="headerlink" title="转发(Forward)和重定向(Redirect)的区别"></a>转发(Forward)和重定向(Redirect)的区别</h4><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p><p><strong>转发（Forward）</strong> 通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面。</p><pre><code class="java">request.getRequestDispatcher(&quot;login_success.jsp&quot;).forward(request, response);</code></pre><p><strong>重定向（Redirect）</strong> 是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 <code>HttpServletResponse</code> 的 <code>setStatus(int status)</code> 方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。</p><ol><li><strong>从地址栏显示来说</strong></li></ol><p>forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</p><ol start="2"><li><strong>从数据共享来说</strong></li></ol><p>forward:转发页面和转发到的页面可以共享request里面的数据. redirect:不能共享数据.</p><ol start="3"><li><strong>从运用地方来说</strong></li></ol><p>forward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</p><h4 id="request-getAttribute-和-request-getParameter-有何区别"><a href="#request-getAttribute-和-request-getParameter-有何区别" class="headerlink" title="request.getAttribute()和 request.getParameter()有何区别"></a>request.getAttribute()和 request.getParameter()有何区别</h4><p><strong>从获取方向来看：</strong></p><p><code>getParameter()</code>是获取 POST/GET 传递的参数值；</p><p><code>getAttribute()</code>是获取对象容器中的数据值；</p><p><strong>从用途来看：</strong></p><p><code>getParameter()</code>用于客户端重定向时，即点击了链接或提交按扭时传值用，即用于在用表单或url重定向传值时接收数据用。</p><p><code>getAttribute()</code> 用于服务器端重定向时，即在 sevlet 中使用了 forward 函数,或 struts 中使用了 mapping.findForward。 getAttribute 只能收到程序用 setAttribute 传过来的值。</p><p>另外，可以用 <code>setAttribute()</code>,<code>getAttribute()</code> 发送接收对象.而 <code>getParameter()</code> 显然只能传字符串。 <code>setAttribute()</code> 是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另一个页面时，应用服务器会把这块内存拷贝另一个页面所对应的内存中。这样<code>getAttribute()</code>就能取得你所设下的值，当然这种方法可以传对象。session也一样，只是对象在内存中的生命周期不一样而已。<code>getParameter()</code>只是应用服务器在分析你送上来的 request页面的文本时，取得你设在表单或 url 重定向时的值。</p><p><strong>总结：</strong></p><p><code>getParameter()</code>返回的是String,用于读取提交的表单中的值;（获取之后会根据实际需要转换为自己需要的相应类型，比如整型，日期类型啊等等）</p><p><code>getAttribute()</code>返回的是Object，需进行转换,可用<code>setAttribute()</code>设置成任意对象，使用很灵活，可随时用</p><h3 id="2-实现会话跟踪的技术有哪些"><a href="#2-实现会话跟踪的技术有哪些" class="headerlink" title="2.实现会话跟踪的技术有哪些"></a>2.实现会话跟踪的技术有哪些</h3><ol><li><strong>使用Cookie</strong> </li></ol><p>Cookie是由http协议制定的，由服务器保存cookie到浏览器，下次浏览器请求服务器把上一次请求得到的cookie归还给服务器。</p><p>从客户端发送Cookie</p><pre><code class="java">Cookie cookie1 = new Cookie(&quot;aaa&quot;,&quot;AAA&quot;);response.addCookie(cookie1);//Cookie不止有name和value属性，还有maxAge，表示Cookie保存的最大时长</code></pre><p>从客户端读取Cookie</p><pre><code class="java"> Cookie[] cookies = request.getCookies();    if(cookies != null){        for(Cookie c:cookies){            out.print(c.getName()+c.getValue()+&quot;&lt;br/&gt;&quot;);        }    }</code></pre><p><strong>优点:</strong> 数据可以持久保存，不需要服务器资源，简单，基于文本的Key-Value</p><p><strong>缺点:</strong> 大小受到限制，用户可以禁用Cookie功能，由于保存在本地，有一定的安全风险。</p><ol start="2"><li><strong>URL 重写</strong> </li></ol><p>在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。</p><p><strong>优点：</strong> 在Cookie被禁用的时候依然可以使用</p><p><strong>缺点：</strong> 必须对网站的URL进行编码，所有页面必须动态生成，不能用预先记录下来的URL进行访问。</p><ol start="3"><li><strong>隐藏的表单域</strong> </li></ol><pre><code class="java">&lt;input type=&quot;hidden&quot; name =&quot;session&quot; value=&quot;...&quot;/&gt;</code></pre><p><strong>优点：</strong> Cookie被禁时可以使用</p><p><strong>缺点：</strong> 所有页面必须是表单提交之后的结果。</p><ol start="4"><li><strong>HttpSession</strong> </li></ol><p>HttpSession 是由JavaWeb提供的，用来会话跟踪的类。session是服务器端对象，保存在服务器端。HttpSession是Servlet三大域对象（request、session、application/ServletContext ))之一，所以它也有setAttribute()、getAttribute（）removeAttribute()方法。HttpSesssion底层依赖Cookie,或是URL重写。</p><p> 在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方 法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用 HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象。与上面三种方式不同的 是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession 中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了 Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。</p><pre><code class="java">HttpSession session = request.getSession();</code></pre><h3 id="3-Cookie和Session的的区别"><a href="#3-Cookie和Session的的区别" class="headerlink" title="3.Cookie和Session的的区别"></a>3.Cookie和Session的的区别</h3><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><p><strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><h3 id="4-监听器"><a href="#4-监听器" class="headerlink" title="4.监听器"></a>4.监听器</h3><p>ServletContextListener(生命周期监听)它有两个方法，一个在出生时调用，一个在死亡时调用。</p><p>ServletContextAttributeListener(属性监听)它有三个方法，一个在添加属性时调用，一个在替换属性时调用，最后一个在移除属性时调用。</p><h3 id="5-过滤器Filter"><a href="#5-过滤器Filter" class="headerlink" title="5.过滤器Filter"></a>5.过滤器Filter</h3><p>可以拦截请求，它会在一组资源的前面执行。</p><p>过滤器的应用场景：执行目标资源前做预处理工作，例如设置编码。通过条件判断是否放行，如检验用户是否已经登录，或者用户IP是否已经被禁用。在目标资源执行后，做一些后续的特殊处理工作，例如把目标资源输出的数据进行处理。</p><h3 id="6-TCP-IP协议"><a href="#6-TCP-IP协议" class="headerlink" title="6.TCP/IP协议"></a>6.TCP/IP协议</h3><p>从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称 TCP/IP 为网际协议群。 </p><h4 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h4><ol><li><strong>UDP</strong></li></ol><ul><li>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。</li><li>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。</li><li>此外，传输途中出现丢包，UDP 也不负责重发。</li><li>甚至当包的到达顺序出现乱序时也没有纠正的功能。</li><li>如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。</li><li>UDP 常用于一下几个方面：1.包总量较少的通信（DNS、SNMP等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN 等特定网络中的应用通信；4.广播通信（广播、多播）。</li></ul><ol start="2"><li><strong>TCP</strong></li></ol><ul><li>TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。</li><li>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</li><li>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。</li></ul><p><strong>1. 端口号</strong></p><p>数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP 网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。</p><p><strong>1.1 根据端口号识别应用</strong></p><p>一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/%E7%AB%AF%E5%8F%A3.jpeg" alt></p><p><strong>1.3 端口号的确定</strong></p><ul><li>标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 0<del>1023 之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 1024</del>49151 之间，不过这些端口号可用于任何通信用途。</li><li>时序分配法：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在49152~65535 之间。</li></ul><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%5C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE.PNG" alt></p><ul><li>第一次握手：客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。</li><li>第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。</li><li>第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="D:%5Cblog%5Csource_posts%5CJ2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%5C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpeg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识回顾</title>
      <link href="/posts/c3fb.html"/>
      <url>/posts/c3fb.html</url>
      
        <content type="html"><![CDATA[<h3 id="Java基础知识回顾"><a href="#Java基础知识回顾" class="headerlink" title="Java基础知识回顾"></a>Java基础知识回顾</h3><h4 id="1-JVM-、JDK-和-JRE"><a href="#1-JVM-、JDK-和-JRE" class="headerlink" title="1.JVM 、JDK 和 JRE"></a>1.JVM 、JDK 和 JRE</h4><ul><li>Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。 </li><li>JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。 </li><li>JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。 </li></ul><p>Java程序经过JDK的javac命令编译为字节码文件，即扩展名为.class的文件,然后由JVM加载翻译为机器代码。</p><p> Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</p><h4 id="2-Java基本类型与数组"><a href="#2-Java基本类型与数组" class="headerlink" title="2.Java基本类型与数组"></a>2.Java基本类型与数组</h4><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><table><thead><tr><th>类型</th><th>型别</th><th>字节</th><th>取值范围</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>整型</td><td>1byte</td><td>-2<sup>7 </sup>~ 2<sup>7</sup>-1</td><td>0</td></tr><tr><td>short</td><td>整型</td><td>2byte</td><td>-2<sup>15</sup> ~ 2<sup>15</sup>-1</td><td>0</td></tr><tr><td>int</td><td>整型</td><td>4byte</td><td>-2<sup>31</sup> ~ 2<sup>31</sup>-1</td><td>0</td></tr><tr><td>long</td><td>整型</td><td>8byte</td><td>-2<sup>63</sup> ~ 2<sup>63</sup>-1</td><td>0L</td></tr><tr><td>float</td><td>浮点型</td><td>4byte</td><td>……</td><td>0.0f</td></tr><tr><td>double</td><td>浮点型</td><td>8byte</td><td>……</td><td>0.0d</td></tr><tr><td>char</td><td>字符型</td><td>2byte</td><td>……</td><td>‘u0000’</td></tr><tr><td>boolean</td><td>布尔型</td><td>1byte</td><td>……</td><td>false</td></tr></tbody></table><h5 id="原码，反码，补码"><a href="#原码，反码，补码" class="headerlink" title="原码，反码，补码"></a>原码，反码，补码</h5><blockquote><p> <strong>原码</strong>:是最简单的机器数表示法。用最高位表示符号位，‘1’表示负号，‘0’表示正号。其他位存放该数的二进制的绝对值。</p><p> <strong>反码：</strong>正数的反码还是等于原码。负数的反码就是他的原码除符号位外，按位取反。</p><p> <strong>补码：</strong>正数的补码等于他的原码。负数的补码等于反码+1。 </p></blockquote><p>计算机没法直接做减法的，它的减法是通过加法来实现的。1010 ：最高位为‘1’,表示这是一个负数，其他三位为‘010’，  即0×2<sup>0</sup>+1×2<sup>1</sup>×+0×2<sup>2</sup>=2 ， 所以1010表示十进制数-2。</p><p>正数之间的加法通常是不会出错的，因为它就是一个很简单的二进制加法。而正数与负数相加，或负数与负数相加，就要引起莫名其妙的结果，这都是该死的符号位引起的。0分为<code>+0</code>和<code>-0</code>也是因他而起。所以原码，虽然直观易懂，易于正值转换。但用来实现加减法的话，运算规则总归是太复杂，于是反码来了。</p><p>我们知道，原码最大的问题就在于一个数加上他的相反数不等于零。</p><p>例如：<code>0001+1001=1010 (1+(-1)=-2)</code> <code>0010+1010=1100 (2+(-2)=-4)</code></p><p>于是反码的设计思想就是冲着解决这一点，既然一个负数是一个正数的相反数，那我们干脆用一个正数按位取反来表示负数试试。  </p><p>byte 表示一个字节，一个字节是 8 位，最高位是符号位。</p><p>那么 8 位能表示的最大值就是 0111 1111，换算成十进制就是 127。</p><p>最小的负数就是1000 0000，（最大的负数是 1111 1111 是负数-1的补码），换算成十进制就是 -128， 10000000 是最小负数的补码表示形式，我们把补码计算步骤倒过来就即可。1000 0000 减 1 得  0111 1111 然后取反 1000 0000 因为负数的补码是其绝对值取反，即 1000 0000 为最小负数的绝对值，而 1000 0000 的十进制表示是 128，所以最小负数是 -128</p><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>声明并且创建一个长度为2的数组</p><p><code>int Array[] = new int[2];</code></p><p>可以为数组分配元素<code>Array[0] = 1</code>,<code>Array[1] = 2</code></p><p>在声明数组的同时也可以给每个数组的元素一个初始值</p><p><code>int Array = {1,2,3,4,5,6,7,8,9}</code></p><p>java采用”数组的数组“声明多维数组，一个二维数组是由若干个一维数组构成的。</p><p><code>int a[][] = new int[][];</code></p><h4 id="3-java面向对象编程特性"><a href="#3-java面向对象编程特性" class="headerlink" title="3.java面向对象编程特性"></a>3.java面向对象编程特性</h4><p>一个java应用程序是由若干个类所构成的，一个class类里面的成员变量有默认值，而局部变量没有默认值。</p><p>如果类中没有编写构造方法，则默认有一个无参数的构造方法, 构造方法主要作用是完成对类对象的初始化工作。 </p><p>创建一个对象包括对象的声明和对象变量的分配。当对象声明之后，对象变量的内存中还没有任何的数据，对象变量为一个空对象，利用<code>new</code>运算符计算出一个十六进制的引用后，对象就诞生了。</p><p><code>Object o = new Object();</code></p><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><blockquote><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问. </p></blockquote><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><blockquote><p> 继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。 </p></blockquote><p>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问,只是拥有。</p><p><strong>对象增强的手段：继承、装饰者模式、动态代理</strong></p><ul><li><p><strong>方法重写</strong></p><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写,发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。另外，如果父类方法访问修饰符为 private 则子类就不能重写该方法。也就是说方法提供的行为改变，而方法的外貌并没有改变。</p><p>方法重写的目的可以隐藏继承的方法，子类通过方法的重写可以把父类的状态和行为改变为自身的状态和行为</p><p><strong>重载</strong>： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。 </p><p><code>float hello(int a,int b){return a+b}</code></p><p><code>float hello(long a,int b){return a-b}</code></p><p><code>float hello(double a,int b){return a*b}</code></p></li><li><p><strong>对象的上转型对象</strong></p><p>假设Animal是Tiger的父类</p><p><code>Animal a = new Tiger();</code></p><p>对象的上转型对象的实体是由子类创建的，上转型对象不能操作子类新增的成员变量，不能调用子类新增的方法，可以访问子类继承或隐藏的成员变量。</p></li></ul><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><blockquote><p>多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）</p></blockquote><h4 id="4-接口与抽象类"><a href="#4-接口与抽象类" class="headerlink" title="4.接口与抽象类"></a>4.接口与抽象类</h4><ol><li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li><li>接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。</li><li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。</li><li>接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！也不允许使用static修饰）。</li><li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li></ol><p>接口中的常量与方法</p><p><code>public static final int MAX = 100</code></p><p><code>public abstract int sum(int a,int b)</code></p><ul><li><strong>接口回调</strong></li></ul><p>接口是java中的一种重要的数据类型，用接口声明的变量称作接口变量。接口属于引用型变量，接口变量中可以存放实现该接口的类的实例的引用。</p><p><code>Com object = new ImpleCom();</code></p><h4 id="5-常见关键字总结"><a href="#5-常见关键字总结" class="headerlink" title="5.常见关键字总结"></a>5.常见关键字总结</h4><h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><blockquote><p>final关键字主要用在三个地方：变量、方法、类。</p><ol><li>对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li><li>当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。</li><li>使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。</li></ol></blockquote><h5 id="static"><a href="#static" class="headerlink" title="static"></a>static</h5><blockquote><p>static 关键字主要有以下四种使用场景：</p><ol><li>修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量存放在 Java 内存区域的方法区。调用格式：类名.静态变量名类名.静态方法名()</li><li>静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</li><li>静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。</li><li>静态导包(用来导入类中的静态资源，1.5之后的新特性): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</li></ol></blockquote><h5 id="this"><a href="#this" class="headerlink" title="this"></a>this</h5><blockquote><p>this关键字用于引用类的当前实例。 例如：</p><p><strong>class</strong> <strong>Manager</strong> {   </p><p>​    Employees[] employees;         </p><p>​    <strong>void</strong> <strong>manageEmployees</strong>() {</p><p>​            <strong>int</strong> totalEmp = <strong>this</strong>.employees.length;</p><p>​           System.out.println(“Total employees: “ + totalEmp); </p><p>​           <strong>this</strong>.report();</p><p>}         </p><p>​    <strong>void</strong> <strong>report</strong>() { } }</p><p>在上面的示例中，this关键字用于两个地方：</p><ul><li>this.employees.length：访问类Manager的当前实例的变量。</li></ul><ul><li>this.report（）：调用类Manager的当前实例的方法。</li></ul><p>此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。</p></blockquote><h5 id="super"><a href="#super" class="headerlink" title="super"></a>super</h5><blockquote><p>super关键字用于从子类访问父类的变量和方法。 例如：</p><p><strong>public</strong> <strong>class</strong> <strong>Super</strong> {    </p><p>​        <strong>protected</strong> <strong>int</strong> number; </p><p>​        <strong>protected</strong> <strong>showNumber</strong>() {        </p><p>​                System.out.println(“number = “ + number);    } </p><p>​                    }  </p><p>​    <strong>public</strong> <strong>class</strong> <strong>Sub</strong> <strong>extends</strong> Super {    </p><p>​    <strong>void</strong> <strong>bar</strong>() {        </p><p>​        <strong>super</strong>.number = 10;        </p><p>​        <strong>super</strong>.showNumber();    } </p><p>}</p><p>在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 showNumber（） 方法。</p></blockquote><p>使用 this 和 super 要注意的问题：</p><ul><li>在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。</li><li>this、super不能用在static方法中。</li></ul><p><a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Basis/final、static、this、super.md" target="_blank" rel="noopener">参考链接</a></p><h4 id="6-自动拆装箱"><a href="#6-自动拆装箱" class="headerlink" title="6.自动拆装箱"></a>6.自动拆装箱</h4><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p><p><code>Integer i = 10 //自动装箱</code></p><p><strong>拆箱</strong>：将包装类型转换为基本数据类型；</p><p><code>int b = i //自动装箱</code></p><p>自动装箱都是通过包装类的<code>valueOf()</code>方法来实现的.自动拆箱都是通过包装类对象的<code>xxxValue()</code>来实现的。<code>Integer integer=Integer.valueOf(1);</code> </p><p><code>int i=integer.intValue();</code> </p><p>Java提供了与基本的数据类型相关的类，实现了对基本数据类型的封装。这些类在java.lang包中，分别是Byte、Boolean、Integer、Short、Long、Float、Double、Character。</p><p>为什么还要提供包装类呢？因为Java是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。比如，在集合类中，我们是无法将int 、double等类型放进去的。因为集合的容器要求元素是Object类型。为了让基本类型也具有对象的特征，就出现了包装类型，它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p><h4 id="7-访问权限"><a href="#7-访问权限" class="headerlink" title="7.访问权限"></a>7.访问权限</h4><p>Java 中一共有四种访问权限控制，其权限控制的大小情况是这样的：public &gt; protected &gt; default(包访问权限) &gt; private  </p><table><thead><tr><th>权限</th><th>同类</th><th>同包</th><th>不同包子类</th><th>不同包非子类</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>default</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h4 id="8-与-equals"><a href="#8-与-equals" class="headerlink" title="8.== 与 equals"></a>8.== 与 equals</h4><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。</p><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li><li>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li></ul><blockquote><pre><code class="java">public boolean equals(Object obj) {    return (this== obj);}</code></pre></blockquote><h4 id="9-常用实用类"><a href="#9-常用实用类" class="headerlink" title="9.常用实用类"></a>9.常用实用类</h4><h5 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h5><p>在Java中，String是一个引用类型，它本身也是一个class。Java把String类定义为final类，因此用户不能扩展String类，即String类不可以有子类。 </p><p><code>String s1 = &quot;Hello!&quot;;</code></p><p> 实际上字符串在<code>String</code>内部是通过一个<code>char[]</code>数组表示的，因此，按下面的写法也是可以的： </p><p><code>String s2 = new String(new char[] {&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;!&#39;});</code></p><ul><li><strong>String类常用的方法：</strong></li></ul><p>（1）是否包含字串    <code>&quot;Hello&quot;.contains(&quot;ll&quot;); // true</code></p><p>（2）判断当前的String对象的字符序列前缀是否是参数指定的String对象的字符序列</p><p><code>&quot;Hello,world!&quot;.startsWith(&quot;He&quot;); // true</code></p><p><code>&quot;Hello,world!&quot;.endsWith(&quot;!&quot;); // true</code></p><p>（3）<code>public boolean contains(String s)</code></p><p>（4）indexOf(String str)从当前String对象的字符序列的0索引位置开始检索首次出现str的字符序列的位置，并返回该位置</p><p><code>String s = &quot;I am a good cat&quot;;</code></p><p><code>s.indexof(&quot;a&quot;); // 值是2</code></p><p><code>s.lastIndexOf(&quot;a&quot;); // 值是13</code></p><p>（5）复制得到字符序列中的start位置至end-1位置上的字符</p><p><code>&quot;Hello&quot;.substring(2, 4); &quot;ll&quot;</code></p><p>（6）使用trim()方法可以移除字符串首尾空白字符。空白字符包括空格，\t，\r，\n：</p><p><code>&quot;  \tHello\r\n &quot;.trim(); // &quot;Hello&quot;</code></p><p>String还提供了isEmpty()和isBlank()来判断字符串是否为空和空白字符串：</p><p><code>&quot;&quot;.isEmpty(); // true，因为字符串长度为0</code><br><code>&quot;  &quot;.isEmpty(); // false，因为字符串长度不为0</code><br><code>&quot;  \n&quot;.isBlank(); // true，因为只包含空白字符</code><br><code>&quot; Hello &quot;.isBlank(); // false，因为包含非空白字符</code></p><p>（7）替换子串</p><p><code>String s = &quot;hello&quot;;</code><br><code>s.replace(&#39;l&#39;, &#39;w&#39;); // &quot;hewwo&quot;，所有字符&#39;l&#39;被替换为&#39;w&#39;</code></p><p>可以通过正则表达式来替换</p><p><code>String s = &quot;A,,B;C ,D&quot;;</code><br><code>s.replaceAll(&quot;[\\,\\;\\s]+&quot;, &quot;,&quot;); // &quot;A,B,C,D&quot;</code></p><p>（8）分割字符串</p><p><code>String s = &quot;A,B,C,D&quot;;</code><br><code>String[] ss = s.split(&quot;\\,&quot;); // {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;}</code></p><ul><li><p><strong>字符串与基本数据类型的转化</strong></p><p>要把任意基本类型或引用类型转换为字符串，可以使用静态方法<code>valueOf()</code>。这是一个重载方法，编译器会根据参数自动选择合适的方法。</p></li></ul><p><code>String s = String.valueOf(123456.78);</code></p><p> 要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为<code>int</code>类型：</p><p> <code>int n1 = Integer.parseInt(&quot;123&quot;); // 123</code></p><p>String和char[]类型可以互相转换，方法是：</p><p><code>char[] cs = &quot;Hello&quot;.toCharArray(); // String -&gt; char[]</code><br><code>String s = new String(cs); // char[] -&gt; String</code></p><h5 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h5><p>Java编译器对String做了特殊处理，使得我们可以直接用+拼接字符串。虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个可变对象，可以预分配缓冲区，这样，往<code>StringBuilder</code>中新增字符时，不会创建新的临时对象：</p><p>String对象的字符序列是不可修改的，与String类不同的是，StringBuffer类的对象的实体的内存空间可以自动的改变大小，便于存放一个可变的字符序列。</p><ul><li><strong>常用方法</strong></li></ul><p>（1）append方法</p><p><code>StringBuffer s = new StringBuffer(&quot;我喜欢&quot;);</code></p><p><code>s.append(&quot;打篮球&quot;);</code></p><p>（2）将参数str指定的字符序列插入到参数index指定的位置</p><p><code>insert(int index, String str)</code></p><p>（3）将对象实体中的字符序列翻转，并返回当前对象的引用</p><p><code>StringBuffer s = new StringBuffer(&quot;Hello&quot;);</code></p><p><code>s.reverse(); //olleH</code></p><p>（4）替换</p><p><code>StringBuffer replace(int startIndex,int endIndex, String str);</code></p><h5 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h5><p>在Java中，由CPU原生提供的整型最大范围是64位long型整数。使用long型整数可以直接通过CPU指令进行计算，速度非常快。如果我们使用的整数范围超过了long型怎么办？这个时候，就只能用软件来模拟一个大整数。java.math.BigInteger就是用来表示任意大小的整数。BigInteger内部用一个int[]数组来模拟一个非常大的整数。</p><p><code>BigInteger bi = new BigInteger(&quot;1234567890&quot;);</code><br><code>System.out.println(bi.pow(5)); // 2867971860299718107233761438093672048294900000</code></p><p> 对<code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算： </p><p><code>BigInteger i1 = new BigInteger(&quot;1234567890&quot;);</code><br><code>BigInteger i2 = new BigInteger(&quot;12345678901234567890&quot;);</code><br><code>BigInteger sum = i1.add(i2); // 12345678902469135780</code></p><p>和<code>long</code>型整数运算比，<code>BigInteger</code>不会有范围限制，但缺点是速度比较慢。也可以把<code>BigInteger</code>转换成<code>long</code>型</p><p><code>BigInteger i = new BigInteger(&quot;123456789000&quot;);</code><br><code>System.out.println(i.longValue()); // 123456789000</code></p><p>可以把BigInteger转换成基本类型。如果BigInteger表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用intValueExact()、longValueExact()等方法，在转换时如果超出范围，将直接抛出ArithmeticException异常。</p><h5 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h5><p>和<code>BigInteger</code>类似，<code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p><pre><code class="java">BigDecimal bd = new BigDecimal(&quot;123.4567&quot;);System.out.println(bd.multiply(bd)); // 15241.55677489</code></pre><p> <code>BigDecimal</code>用<code>scale()</code>表示小数位数，例如 </p><p><code>BigDecimal d1 = new BigDecimal(&quot;123.4500&quot;); //4,4位小数</code></p><p>《阿里巴巴Java开发手册》中提到：浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。 具体原理和浮点数的编码方式有关，出现了精度丢失，我们下面直接上实例：</p><pre><code class="java">float a = 1.0f - 0.9f;float b = 0.9f - 0.8f;System.out.println(a);// 0.100000024System.out.println(b);// 0.099999964System.out.println(a == b);// false</code></pre><p>对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断。通过 setScale方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA会提示。</p><pre><code class="java">BigDecimal m = new BigDecimal(&quot;1.255433&quot;);BigDecimal n = m.setScale(3,BigDecimal.ROUND_HALF_DOWN);System.out.println(n);// 1.255</code></pre><ul><li><strong>比较BigDecimal</strong></li></ul><p>在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等</p><pre><code class="java">BigDecimal d1 = new BigDecimal(&quot;123.456&quot;);BigDecimal d2 = new BigDecimal(&quot;123.45600&quot;);System.out.println(d1.equals(d2)); // false,因为scale不同System.out.println(d1.equals(d2.stripTrailingZeros())); // true,因为d2去除尾部0后scale变为2System.out.println(d1.compareTo(d2)); // 0</code></pre><p> 必须使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于 </p><p>如果查看<code>BigDecimal</code>的源码，可以发现，实际上一个<code>BigDecimal</code>是通过一个<code>BigInteger</code>和一个<code>scale</code>来表示的，即<code>BigInteger</code>表示一个完整的整数，而<code>scale</code>表示小数位数：</p><pre><code>public class BigDecimal extends Number implements Comparable&lt;BigDecimal&gt; {    private final BigInteger intVal;    private final int scale;}</code></pre><p><code>BigDecimal</code>也是从<code>Number</code>继承的，也是不可变对象。</p><ul><li><strong>总结</strong></li></ul><p>BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。</p><p>BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念</p><p>比较<code>BigDecimal</code>的值是否相等，必须使用<code>compareTo()</code>而不能使用<code>equals()</code>。 </p><h5 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h5><p>Arrays类的常见操作</p><ol><li>排序 : sort()</li><li>查找 : binarySearch()</li><li>比较: equals()</li><li>填充 : fill()</li><li>转列表: asList()</li><li>转字符串 : toString()</li><li>复制: copyOf()</li></ol><p><code>Arrays.asList()</code>在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个List集合。 <code>Arrays.asList()</code>是泛型方法，传入的对象必须是对象数组。 </p><pre><code class="java">String[] myArray = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot; }； List&lt;String&gt; myList = Arrays.asList(myArray);//上面两个语句等价于下面一条语句List&lt;String&gt; myList = Arrays.asList(&quot;Apple&quot;,&quot;Banana&quot;, &quot;Orange&quot;);</code></pre><p><strong>如何将数组转换为ArrayList</strong></p><ol><li>最简便的方法</li></ol><p><code>List list = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</code></p><ol start="2"><li>使用 Java8 的Stream</li></ol><pre><code class="java">Integer [] myArray = { 1, 2, 3 };List myList = Arrays.stream(myArray).collect(Collectors.toList());//基本类型也可以实现转换（依赖boxed的装箱操作）int [] myArray2 = { 1, 2, 3 };List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());</code></pre><h5 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h5><pre><code class="java">void reverse(List list)//反转void shuffle(List list)//随机排序void sort(List list)//按自然排序的升序排序void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑void swap(List list, int i , int j)//交换两个索引位置的元素void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。</code></pre><h4 id="10-集合"><a href="#10-集合" class="headerlink" title="10.集合"></a>10.集合</h4><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/%E9%9B%86%E5%90%88.PNG" alt></p><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p> <code>ArrayList</code>在内部使用了数组来存储所有元素。例如，一个ArrayList拥有5个元素，实际数组大小为<code>6</code>（即有一个空位，当添加一个元素并指定索引到<code>ArrayList</code>时，<code>ArrayList</code>自动移动需要移动的元素， 然后，往内部指定索引的数组位置添加一个元素，然后把<code>size</code>加<code>1</code>， 继续添加元素，但是数组已满，没有空闲位置的时候，<code>ArrayList</code>先创建一个更大的新数组，然后把旧数组的所有元素复制到新数组，紧接着用新数组取代旧数组，现在，新数组就有了空位，可以继续添加一个元素到数组末尾，同时<code>size</code>加<code>1</code>。</p><p><code>List</code>接口，可以看到几个主要的接口方法：</p><ul><li>在末尾添加一个元素：<code>void add(E e)</code></li><li>在指定索引添加一个元素：<code>void add(int index, E e)</code></li><li>删除指定索引的元素：<code>int remove(int index)</code></li><li>删除某个元素：<code>int remove(Object e)</code></li><li>获取指定索引的元素：<code>E get(int index)</code></li><li>获取链表大小（包含元素的个数）：<code>int size()</code></li></ul><h5 id="List的遍历"><a href="#List的遍历" class="headerlink" title="List的遍历"></a>List的遍历</h5><ul><li><strong>RandomAccess接口</strong></li></ul><blockquote><p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。为什么呢？我觉得还是和底层数据结构有关！<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O（1），所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O（n），所以不支持快速随机访问。<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！ </p></blockquote><p>实现了 <code>RandomAccess</code> 接口的list，优先选择普通 for 循环 ，其次 foreach,</p><p>未实现 <code>RandomAccess</code>接口的list，优先选择iterator遍历（foreach遍历底层也是通过iterator实现的,），大size的数据，千万不要使用普通for循环</p><p>普通for循环、foreach遍历、 iterator 遍历</p><pre><code class="java">List&lt;String&gt; list = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);for(int i = 0;i&lt;list.size();i++){    System.out.println(list.get(i));}for (String s: list) {    System.out.println(s);}Iterator iterator = list.iterator();while(iterator.hasNext()){    String s = (String)iterator.next();    System.out.println(s);}</code></pre><h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><p><code>Map</code>是一种键-值映射表，当我们调用<code>put(K key, V value)</code>方法时，就把<code>key</code>和<code>value</code>做了映射并放入<code>Map</code>。当我们调用<code>V get(K key)</code>时，就可以通过<code>key</code>获取到对应的<code>value</code>。如果<code>key</code>不存在，则返回<code>null</code>。和<code>List</code>类似，<code>Map</code>也是一个接口，最常用的实现类是<code>HashMap</code>。 </p><h5 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h5><pre><code class="java">Map&lt;Object,String&gt; map =new HashMap();        map.put(null,&quot;hello&quot;);        map.put(&quot;k1&quot;,&quot;v1&quot;);        Set set = map.entrySet();        Iterator its = set.iterator();        while(its.hasNext()){            Map.Entry entry = (Map.Entry)its.next();            Object key = entry.getKey();            Object value = entry.getValue();            System.out.println(key +&quot; &quot;+value);}</code></pre><pre><code class="java">Set keySet = map.keySet();//获取键的集合Iterator it = keySet.iterator();//迭代键的集合    while(it.hasNext()) {        Object key = it.next();        Object value = map.get(key);//获取每个键所对应的值        System.out.println(key+&quot; &quot;+value);}</code></pre><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><ul><li><strong>HashSet如何检查重复</strong><br>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。</li></ul><p><strong>hashCode（）与equals（）的相关规定：</strong></p><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个equals方法返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><h5 id="List-Set-Map三者的区别？"><a href="#List-Set-Map三者的区别？" class="headerlink" title="List,Set,Map三者的区别？"></a>List,Set,Map三者的区别？</h5><ul><li><strong>List(对付顺序的好帮手)：</strong> List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</li><li><strong>Set(注重独一无二的性质):</strong> 不允许重复的集合。不会有多个元素引用相同的对象。</li><li><strong>Map(用Key来搜索的专家):</strong> 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</li></ul><h5 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h5><ul><li><p><strong>1. 是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</p></li><li><p><strong>2. 底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别）</p></li><li><p><strong>3. 插入和删除是否受元素位置的影响：</strong></p><p> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</p><p> ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O（1），如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></p></li><li><p><strong>4. 是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p></li><li><p><strong>5. 内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</p></li></ul><h5 id="equals和hashCode"><a href="#equals和hashCode" class="headerlink" title="equals和hashCode"></a>equals和hashCode</h5><p>HashMap之所以能根据key直接拿到value，原因是它内部通过空间换时间的方法，用一个大数组存储所有value，并根据key直接计算出value应该存储在哪个索引。</p><p>我们放入<code>Map</code>的<code>key</code>是字符串<code>&quot;a&quot;</code>，但是，当我们获取<code>Map</code>的<code>value</code>时，传入的变量不一定就是放入的那个<code>key</code>对象。换句话讲，两个<code>key</code>应该是内容相同，但不一定是同一个对象。</p><pre><code class="java">String key1 = &quot;a&quot;;Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();map.put(key1, 123);String key2 = new String(&quot;a&quot;);map.get(key2); // 123System.out.println(key1 == key2); // falseSystem.out.println(key1.equals(key2)); // true</code></pre><p>在Map的内部，对key做比较是通过equals()实现的，这一点和List查找元素需要正确覆写equals()是一样的，即正确使用Map必须保证：作为key的对象必须正确覆写equals()方法。我们经常使用String作为key，因为String已经正确覆写了equals()方法。但如果我们放入的key是一个自己写的类，就必须保证正确覆写了equals()方法。</p><p>通过key计算索引的方式就是调用key对象的hashCode()方法，它返回一个int整数。HashMap正是通过这个方法直接定位key对应的value的索引，继而直接返回value。</p><p>因此，正确使用<code>Map</code>必须保证：</p><ol><li>作为<code>key</code>的对象必须正确覆写<code>equals()</code>方法，相等的两个<code>key</code>实例调用<code>equals()</code>必须返回<code>true</code>；</li><li>作为<code>key</code>的对象还必须正确覆写<code>hashCode()</code>方法，且<code>hashCode()</code>方法要严格遵循以下规范：</li></ol><ul><li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等；</li><li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等；</li></ul><p>即对应两个实例<code>a</code>和<code>b</code>：</p><ul><li>如果<code>a</code>和<code>b</code>相等，那么<code>a.equals(b)</code>一定为<code>true</code>，则<code>a.hashCode()</code>必须等于<code>b.hashCode()</code>；</li><li>如果<code>a</code>和<code>b</code>不相等，那么<code>a.equals(b)</code>一定为<code>false</code>，则<code>a.hashCode()</code>和<code>b.hashCode()</code>尽量不要相等。</li></ul><p>上述第一条规范是正确性，必须保证实现，否则<code>HashMap</code>不能正常工作。</p><p>而第二条如果尽量满足，则可以保证查询效率，因为不同的对象，如果返回相同的<code>hashCode()</code>，会造成<code>Map</code>内部存储冲突，使存取的效率下降。</p><p>编写<code>equals()</code>和<code>hashCode()</code>遵循的原则是：</p><p><code>equals()</code>用到的用于比较的每一个字段，都必须在<code>hashCode()</code>中用于计算；<code>equals()</code>中没有使用到的字段，绝不可放在<code>hashCode()</code>中计算。</p><p>编写<code>equals()</code>方法如下：</p><pre><code class="java">public boolean equals(Object o) {    if (o instanceof Person) {        Person p = (Person) o;        return Objects.equals(this.name, p.name) &amp;&amp; this.age == p.age;    }    return false;}</code></pre><p>因此，我们总结一下<code>equals()</code>方法的正确编写方法：</p><ol><li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li><li>用<code>instanceof</code>判断传入的待比较的<code>Object</code>是不是当前类型，如果是，继续比较，否则，返回<code>false</code>；</li><li>对引用类型用<code>Objects.equals()</code>比较，对基本类型直接用<code>==</code>比较。</li></ol><p>使用<code>Objects.equals()</code>比较两个引用类型是否相等的目的是省去了判断<code>null</code>的麻烦。两个引用类型都是<code>null</code>时它们也是相等的。</p><p>编写<code>hashCode()</code>方法：</p><pre><code class="java">int hashCode() {    return Objects.hash(firstName, lastName, age);}</code></pre><p>所以，编写<code>equals()</code>和<code>hashCode()</code>遵循的原则是：</p><p><code>equals()</code>用到的用于比较的每一个字段，都必须在<code>hashCode()</code>中用于计算；<code>equals()</code>中没有使用到的字段，绝不可放在<code>hashCode()</code>中计算。</p><p>另外注意，对于放入<code>HashMap</code>的<code>value</code>对象，没有任何要求。</p><h5 id="HashMap-和-HashSet区别"><a href="#HashMap-和-HashSet区别" class="headerlink" title="HashMap 和 HashSet区别"></a>HashMap 和 HashSet区别</h5><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p><table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>实现了Map接口</td><td>实现Set接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用 <code>put（）</code>向map中添加元素</td><td>调用 <code>add（）</code>方法向Set中添加元素</td></tr><tr><td>HashMap使用键（Key）计算Hashcode</td><td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，</td></tr></tbody></table><h4 id="11-泛型"><a href="#11-泛型" class="headerlink" title="11.泛型"></a>11.泛型</h4><p> 泛型就是定义一种模板，例如<code>ArrayList</code>，然后在代码中为用到的类创建对应的<code>ArrayList&lt;类型&gt;</code>，</p><pre><code class="java">ArrayList&lt;String&gt; strList = new ArrayList&lt;String&gt;();</code></pre><p> 这样一来，既实现了编写一次，万能匹配，又通过编译器保证了类型安全：这就是泛型。 </p><p> 注意泛型的继承关系：可以把<code>ArrayList</code>向上转型为<code>List</code>（<code>T</code>不能变！)</p><h5 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h5><pre><code class="java">public class Generic&lt;T&gt;{     //key这个成员变量的类型为T,T的类型由外部指定      private T key;    public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定        this.key = key;    }    public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定        return key;    }}</code></pre><h5 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h5><p>除了<code>ArrayList</code>使用了泛型，还可以在接口中使用泛型。例如，<code>Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code>Comparable</code>这个泛型接口。</p><pre><code>public interface Comparable&lt;T&gt; {    /**     * 返回-1: 当前实例比参数o小     * 返回0: 当前实例与参数o相等     * 返回1: 当前实例比参数o大     */    int compareTo(T o);}</code></pre><p>泛型是一种类似”模板代码“的技术，不同语言的泛型实现方式不一定相同。</p><p>Java语言的泛型实现方式是擦拭法（Type Erasure）。</p><p>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。</p><p> Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型<code>T</code>视为<code>Object</code>处理，但是，在需要转型的时候，编译器会根据<code>T</code>的类型自动为我们实行安全地强制转型。 </p><p>要实例化<code>T</code>类型，我们必须借助额外的<code>Class</code>参数：</p><pre><code>public class Pair&lt;T&gt; {    private T first;    private T last;    public Pair(Class&lt;T&gt; clazz) {        first = clazz.newInstance();        last = clazz.newInstance();    }}</code></pre><p>上述代码借助<code>Class</code>参数并通过反射来实例化<code>T</code>类型，使用的时候，也必须传入<code>Class</code>。例如：</p><pre><code>Pair&lt;String&gt; pair = new Pair&lt;&gt;(String.class);</code></pre><p>因为传入了<code>Class</code>的实例，所以我们借助<code>String.class</code>就可以实例化<code>String</code>类型。</p><h5 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h5><p> 一个类可以继承自一个泛型类。  在继承了泛型类型的情况下，子类可以获取父类的泛型类型。</p><h5 id="上下界通配符"><a href="#上下界通配符" class="headerlink" title="上下界通配符"></a>上下界通配符</h5><p>使用<code>&lt;? extends Number&gt;</code>的泛型定义称之为上界通配符，即把泛型类型的上界限定在<code>Number</code>了，除了可以传入<code>Pair&lt;Number&gt;</code>类型，我们还可以传入<code>Pair&lt;Double&gt;</code>类型，<code>Pair&lt;BigDecimal&gt;</code>类型等等，因为<code>Double</code>和<code>BigDecimal</code>都是<code>Number</code>的子类。 </p><p> 使用<code>extends</code>通配符表示可以读，不能写。 </p><p>使用类似<code>&lt;? super Integer&gt;</code>通配符作为方法参数时表示：</p><ul><li>方法内部可以调用传入<code>Integer</code>引用的方法，例如：<code>obj.setFirst(Integer n);</code>；</li><li>方法内部无法调用获取<code>Integer</code>引用的方法（<code>Object</code>除外），例如：<code>Integer n = obj.getFirst();</code>。</li></ul><p>即使用<code>super</code>通配符表示只能写不能读。</p><h4 id="12-反射"><a href="#12-反射" class="headerlink" title="12.反射"></a>12.反射</h4><p>反射的原理</p><p>应用在一些通用性比较高的代码中，后面学习到的框架，大多数都是使用反射来实现的。在框架开发中，都是基于配置文件来开发的。在配置文件中配置了类，可以通过反射得到类中的所有的内容，可以让类中的某个方法执行。</p><p>将java文件保存到硬盘(.java文件），编译java文件，得到(.class)文件，使用JVM，把class文件通过类加载器加载到内存中。万事万物皆对象，class文件在内存中使用class类表示。当使用反射时，首先需要获取到class类，得到了这个类之后，就可以得到Class文件里面的所有的内容，包括属性、构造方法、普通方法。属性通过一个类File、构造方法通过Constructor、普通方法通过Method。 </p><p>使用反射首先需要得到Class类：类名.class、对象.getClass()、使用Class.forName(“路径”)</p><pre><code class="java">//获取class类Class c1 = Person.class;Class c2 = new Person().getClass();Class c3 = Class.forName(&quot;cn.text.text01.Person&quot;);</code></pre><p>可以不通过new，得到实例 <code>Person p = (Person)c3.newInstance();</code> </p><h4 id="13-并发"><a href="#13-并发" class="headerlink" title="13.并发"></a>13.并发</h4><h5 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h5><ul><li>进程是代码在数据集合上的一次运行活动， 是系统进行资源分配和调度的基本单位，进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</li><li>线程则是进程的一个执行路径， 一个进程中至少有一个线程，进程中 的多个线程共享进程的资源。</li></ul><p>程序计数器</p><h5 id="java中的线程"><a href="#java中的线程" class="headerlink" title="java中的线程"></a>java中的线程</h5><p><strong>1.线程的状态与生命周期</strong></p><ul><li><p>新建：当一个<code>Thread</code>类或其子类的对象被声明并创建时，新生的线程对象处于新建状态。此时它已经有了相应的内存空间和其他资源</p></li><li><p>运行：线程创建之后仅仅是占有了内存资源，在JVM管理的线程中还没有这个线程，此线程调用<code>start()</code>方法通知JVM，这样JVM就会知道又有一个新线程排队等候切换了。</p></li><li><p>中断：有4种原因的中断。<strong>a.</strong>线程使用CPU资源期间，执行了<code>sleep(int millsecond)</code>方法，是当前线程处于休眠状态。<strong>b.</strong>执行了<code>wait()</code>方法，使当前线程进入等待状态。<strong>c.</strong>线程执行某个操作进入阻塞状态<strong>d.</strong>JVM将CPU的资源从当前线程切换给其他线程，使本线程让出CPU的使用权处于中断状态。</p></li><li><p>死亡</p></li></ul><p><strong>2.线程的创建与运行</strong></p><p>Java 中有三种线程创建方式，分别为实现 Runnable 接口的 run 方法，继承 Thread 类 并重写 run 的方法，使用 Fu阳reTask 方式。</p><pre><code class="java">public class ThreadTest extends Thread{    public void run() {        System.out.println(&quot;Hello啊&quot;);    }    public static void main(String[] args) {        ThreadTest t = new ThreadTest();        t.start();    }}</code></pre><pre><code class="java">public class ThreadRunnable implements Runnable{    @Override    public void run() {        System.out.println(&quot;I am a thread&quot;);    }    public static void main(String[] args) {        ThreadRunnable t = new ThreadRunnable();        new Thread(t).start();    }}</code></pre><pre><code class="java">public class ThreadCaller implements Callable&lt;String&gt;{    @Override    public String call() throws Exception {        return &quot;Hello&quot;;    }    public static void main(String[] args) {        //创建异步任务        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(new ThreadCaller());        //启动线程        new Thread(futureTask).start();        try{            //等待任务执行完毕，并返回结果            String result = futureTask.get();            System.out.println(result);        }catch(InterruptedException | ExecutionException e){            e.printStackTrace();        }    }}</code></pre><p>小结 ： 使用继承方式的好处是方便传参，你可以在子类里面添加成员变量，通过 set 方法设置参数或者通过构造函数进行传递，而如果使用 Runnable 方式，则只能使用主线 程里面被声明为 final 的变量。不好的地方是 Java 不支持多继承，如果继承了 Thread 类， 那么子类不能再继承其他类，而 Runable 则没有这个限制。前两种方式都没办法拿到任务 的返回结果，但是 Futuretask 方式可以。</p><h5 id="理解线程上下文切换"><a href="#理解线程上下文切换" class="headerlink" title="理解线程上下文切换"></a>理解线程上下文切换</h5><blockquote><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p><p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p><p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p></blockquote><h5 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h5><ul><li><p><strong>什么是线程死锁</strong></p><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象， 在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去</p></li></ul><blockquote><p>死锁的产生必须具备以 下四个条件。<br>· 互斥条件： 指线程对己经获取到的资源进行排它性使用 ， 即该资源同时只由一个线 程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资 源的线程释放该资源。</p><p> · 请求并持有条件 ： 指一个线程己经持有了至少一个资源， 但又提出了新的资源请求， 而新资源己被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己经获取的资源。</p><p> · 不可剥夺条件 ： 指线程获取到的资源在自己使用完之前不能被其他线程抢占， 只有 在自己使用完毕后才由 自 己释放该资源。</p><p> · 环路等待条件 ： 指在发生死锁时， 必然存在一个线程→资源的环形链， 即线程集合 {TO , TL T2，…， Tn｝中 的 TO 正在等待一个 Tl 占用 的资源， Tl 正在等待 T2 占 用的资源，……Tn 正在等待己被 TO 占用的资源。</p></blockquote><ul><li>如何避免死锁？</li></ul><p><strong>破坏互斥条件</strong></p><p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p><p><strong>破坏请求与保持条件</strong></p><p>一次性申请所有的资源。</p><p><strong>破坏不剥夺条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>破坏循环等待条件</strong></p><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p><h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h5><blockquote><p>ThreadLocal 是 JDK 包提供的，它提供了线程本地变量，也就是如果你创建了 一个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的一个本地副本。 当多 个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问 题。创建一个 ThreadLocal 变量后，每个线程都会复制一个变量到自己的本地内存</p></blockquote><h5 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h5><blockquote><p>synchronized 块是 Java 提供的一种原子性内置锁， Java 中的每个对象都可以把它当作 一个同步锁来使用 ， 这些 Java 内置的使用者看不到的锁被称为内部锁，也叫作监视器锁。 线程的执行代码在进入 synchronized 代码块前会自动获取内部锁，这时候其他线程访问该 同步代码块时会被阻塞挂起。拿到内部锁的线程会在正常退出同步代码块或者抛出异常后 或者在同步块内调用了该内置锁资源的 wait 系列方法时释放该内置锁。 内置锁是排它锁， 也就是当一个线程获取这个锁后， 其他线程必须等待该线程释放锁后才能获取该锁。</p></blockquote><h4 id="14-Java8新特性"><a href="#14-Java8新特性" class="headerlink" title="14.Java8新特性"></a>14.Java8新特性</h4><h5 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h5><p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。 </p><p>排列字符串</p><pre><code class="java">List&lt;String&gt; list = Arrays.asList(&quot;Tom&quot;,&quot;City&quot;,&quot;Jone&quot;,&quot;Alice&quot;,&quot;Robby&quot;);Collections.sort(list, new Comparator&lt;String&gt;() {            @Override            public int compare(String o1, String o2) {                return o1.compareTo(o2);            }});</code></pre><p>我们可以使用Lambda表达式</p><pre><code class="java">Collections.sort(list, (String a, String b) -&gt; {    return b.compareTo(a);});</code></pre><p>我们还可以写的更加的简短</p><pre><code class="java">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</code></pre><p>我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 <code>@FunctionalInterface</code>注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。</p><pre><code class="java">//转换器@FunctionalInterface    interface Converter&lt;T,V&gt;{        T convert(V from);}Converter&lt;Integer,String&gt; converter = from -&gt; Integer.parseInt(from);Integer c = converter.convert(&quot;123&quot;);System.out.println(c);</code></pre><h5 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h5><p>方法引用通过方法的名字来指向一个方法。</p><p>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p><p>方法引用使用一对冒号 <strong>::</strong> 。</p><p>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用 , 上面的代码还可以通过静态方法引用来表示： </p><pre><code class="java">Converter&lt;Integer,String&gt; converter = Integer::parseInt;</code></pre><p> 接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类： </p><pre><code class="java">class Person {    String firstName;    String lastName;    Person() {}    Person(String firstName, String lastName) {        this.firstName = firstName;        this.lastName = lastName;    }}</code></pre><p> 接下来我们指定一个用来创建Person对象的对象工厂接口： </p><pre><code class="java">interface PersonFactory&lt;P extends Person&gt; {    P create(String firstName, String lastName);}</code></pre><p> 这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂： </p><pre><code class="java">PersonFactory&lt;Person&gt; personFactory = Person::new;Person person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;);</code></pre><p> 我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。 </p><p> <strong>lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）</strong> </p><h5 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h5><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为 lambda 表达式。</p><p> Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下： </p><pre><code class="java">interface Formula {    double calculate(int a);    default double sqrt(int a) {        return Math.sqrt(a);    }}</code></pre><p>Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。 </p><pre><code class="java">Formula formula = new Formula() {    @Override    public double calculate(int a) {        return sqrt(a * 100);    }};formula.calculate(100);     // 100.0formula.sqrt(16);           // 4.0</code></pre><p>接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。Lambda表达式中是无法访问到默认方法的，以下代码将无法编译： </p><pre><code class="java">Formula formula = (a) -&gt; sqrt( a * 100);Built-in Functional Interfaces</code></pre><p> JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。 </p><h5 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h5><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p><ul><li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li><li>数据源 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li><li>聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li></ul><p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p><ul><li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li><li><strong>内部迭代</strong>： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li></ul><h5 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h5><ul><li><strong>Clock时钟</strong></li></ul><p>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。 </p><pre><code class="java">Clock clock = Clock.systemDefaultZone();long millis = clock.millis();System.out.println(millis);</code></pre><ul><li><strong>Timezones 时区</strong> </li></ul><p>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。 </p><pre><code class="java">ZoneId currentZone = ZoneId.systemDefault();System.out.println(&quot;当期时区: &quot; + currentZone);</code></pre><ul><li><strong>LocalDateTime</strong></li></ul><pre><code class="java">LocalDateTime currentTime = LocalDateTime.now();System.out.println(&quot;当前时间: &quot; + currentTime);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL语句</title>
      <link href="/posts/e7f7.html"/>
      <url>/posts/e7f7.html</url>
      
        <content type="html"><![CDATA[<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><ul><li><strong>基本查询</strong></li></ul><p>SELECT column_name,column_name FROM table_name;</p><p>SELECT * FROM table_name;</p><p>SELECT DISTINCT column_name FROM table_name;</p><blockquote><p>DISTINCT 关键词用于返回唯一不同的值。</p></blockquote><p>SELECT * FROM table_name WHERE column_name =value;</p><blockquote><p>WHERE 子句用于提取那些满足指定条件的记录。</p></blockquote><p>SELECT * FROM table_name WHERE country=’USA’ OR id=1</p><blockquote><p>如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</p><p>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p></blockquote><p>SELECT column_name FROM table_name ORDER BY column_name DESC;</p><blockquote><p>ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。</p></blockquote><ul><li><strong>插入</strong></li></ul><p>INSERT INTO table_name VALUES (value1,value2,value3,…);</p><p>INSERT INTO table_name (column1,column2,column3,…) VALUES (value1,value2,value3,…);</p><blockquote><p>插入的第二种形式需要指定列名及被插入的值：</p></blockquote><ul><li><strong>更新</strong></li></ul><p>UPDATE table_name SET column1=value1,column2=value2 WHERE some_column=some_value;</p><ul><li><strong>删除</strong></li></ul><p>DELETE FROM table_name WHERE some_column=some_value;</p><h4 id="高级语句"><a href="#高级语句" class="headerlink" title="高级语句"></a>高级语句</h4><p> SELECT * FROM table_name <strong>LIMIT</strong> 2,3; </p><blockquote><p>LIMIT 语句来选取指定的条数数据，2,3表示从第二行开始往后取3条数据</p></blockquote><p>SELECT * FROM table_name WHERE name <strong>LIKE</strong> ‘G%’;</p><blockquote><p>上面的SQL语句选取 name 以字母 “G” 开始的所有客户：</p></blockquote><p>select * from table_city where Address <strong>not like</strong> ‘%市’</p><blockquote><p>上面的SQL语句选取不以“市”结尾的城市</p></blockquote><p><strong><em>SQL简单通配符</em></strong></p><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td>%</td><td>替代 0 个或多个字符</td></tr><tr><td>_</td><td>替代一个字符</td></tr></tbody></table><p>SELECT * FROM table_city WHERE name <strong>IN</strong> (‘北京市’,’天津市’);</p><blockquote><p> IN 操作符允许您在 WHERE 子句中规定多个值。 </p></blockquote><p>SELECT * FROM table_person WHERE age <strong>BETWEEN</strong> 18 <strong>AND</strong> 30;</p><blockquote><p> 上面的SQL语句选取年龄介于 1 到 20 之间的人的数据</p></blockquote><p>SELECT column_name(s) FROM table1 <strong>INNER JOIN</strong> table2 <strong>ON</strong> table1.column_name=table2.column_name</p><p>SELECT column_name(s) FROM table1 <strong>LEFT JOIN</strong> table2 <strong>ON</strong> table1.column_name=table2.column_name</p><blockquote><p> LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。 </p></blockquote><p>SELECT column_name(s) FROM table1 <strong>RIGHT JOIN</strong> table2 <strong>ON</strong> table1.column_name=table2.column_name</p><blockquote><p> RIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。 </p></blockquote><p>SELECT column_name(s) FROM table1<br><strong>UNION</strong><br>SELECT column_name(s) FROM table2;</p><blockquote><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p><p>请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。</p></blockquote><p>SELECT column_name, aggregate_function(column_name)<br>FROM table_name<br>WHERE column_name operator value<br><strong>GROUP BY</strong> column_name;</p><blockquote><p>GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。</p></blockquote><p>SELECT column_name, aggregate_function(column_name)<br>FROM table_name<br>WHERE column_name operator value<br>GROUP BY column_name<br><strong>HAVING</strong> aggregate_function(column_name) operator value; </p><blockquote><p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。</p><p>HAVING 子句可以让我们筛选分组后的各组数据。</p></blockquote><h4 id="SQL函数"><a href="#SQL函数" class="headerlink" title="SQL函数"></a>SQL函数</h4><p>SELECT <strong>AVG</strong>(column_name) FROM table_name</p><p>SELECT <strong>COUNT</strong>(*) FROM table_name</p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>SQL语句<a href="https://www.nowcoder.com/ta/sql" target="_blank" rel="noopener">牛客网</a>练习</p>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/posts/2c2a.html"/>
      <url>/posts/2c2a.html</url>
      
        <content type="html"><![CDATA[<h3 id="最常用的排序——快速排序"><a href="#最常用的排序——快速排序" class="headerlink" title="最常用的排序——快速排序"></a>最常用的排序——快速排序</h3><p>假设我们现在对“6  1  2  7  9  3  4  5  10  8”这 10个数进行排序。首先在这个序列中随 便找一个数作为<strong>基准数</strong>（不要被这个名词吓到了，这就是一个用来参照的数，待会儿你就知 道它用来做啥了）。为了方便，就让第一个数 6 作为基准数吧。接下来，需要将这个序列中 所有比基准数大的数放在 6的右边，比基准数小的数放在 6的左边，类似下面这种排列。 </p><p><strong>3  1  2  5  4  6  9  7  10  8</strong> </p><p>在初始状态下，数字 6在序列的第 1位。我们的目标是将 6挪到序列中间的某个位置， 假设这个位置是 k。现在就需要寻找这个 k，并且以第 k位为分界点，左边的数都小于等于 6， 右边的数都大于等于 6。想一想，你有办法可以做到这点吗？ 给你一个提示吧。请回忆一下冒泡排序是如何通过“交换”一步步让每个数归位的。此时你也可以通过“交换”的方法来达到目的。具体是如何一步步交换呢？方法其实很简单：分别从初始序列“6  1  2  7  9  3  4  5  10  8”两端开始“探测”。先从 右往左找一个小于 6的数，再从左往右找一个大于 6的数，然后交换它们。这里可以用两个 变量 i和 j，分别指向序列左边和右边。我们为这两个变量起个好听的名字“哨兵 i”和 “哨兵 j”。刚开始的时候让哨兵 i指向序列的左边（即 i=1），指向数字 6。让哨兵 j指向序 列的右边（即 j=10），指向数字 8。 </p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/1111.PNG" alt></p><p>首先哨兵 j开始出动。因为此处设置的基准数是左边的数，所以需要让哨兵 j先出动， 这一点非常重要（请自己想一想为什么）。哨兵 j 一步一步地向左挪动（即 j），直到找到 一个小于 6的数停下来。接下来哨兵 i再一步一步向右挪动（即 i++），直到找到一个大于 6 的数停下来。后哨兵 j停在了数字 5面前，哨兵 i停在了数字 7面前。 </p><p> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/22222.PNG" alt></p><p>现在交换哨兵 i和哨兵 j所指向的元素的值。交换之后的序列如下。 </p><p><strong>6  1  2  <u>5</u>  9  3  4  <u>7</u>  10  8</strong></p><p>到此，第一次交换结束。接下来哨兵 j继续向左挪动（再次友情提醒，每次必须是哨兵 j先出发）。他发现了 4（比基准数 6要小，满足要求）之后停了下来。哨兵 i也继续向右挪 动，他发现了 9（比基准数 6要大，满足要求）之后停了下来。此时再次进行交换，交换之 后的序列如下。 </p><p><strong>6  1  2  5  <u>4</u>  3  <u>9</u>  7  10  8</strong></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/33333.PNG" alt></p><p>  第二次交换结束，“探测”继续。哨兵 j继续向左挪动，他发现了 3（比基准数 6要小， 满足要求）之后又停了下来。哨兵 i 继续向右移动，糟啦！此时哨兵 i 和哨兵 j 相遇了，哨 兵 i和哨兵 j都走到3面前。说明此时“探测”结束。我们将基准数 6和 3进行交换。交换之后的序列如下。 </p><p><strong><u>3</u>  1  2  5  4  <u>6</u>  9  7  10  8</strong> </p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/4444.PNG" alt></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/55555.PNG" alt></p><p>到此第一轮“探测”真正结束。此时以基准数 6为分界点，6左边的数都小于等于 6，6 右边的数都大于等于 6。回顾一下刚才的过程，其实哨兵 j的使命就是要找小于基准数的数， 而哨兵 i的使命就是要找大于基准数的数，直到 i和 j碰头为止。 OK，解释完毕。现在基准数 6 已经归位，它正好处在序列的第 6 位。此时我们已经将 原来的序列，以 6为分界点拆分成了两个序列，左边的序列是“3  1  2  5  4”，右边的序列是“9  7  10  8”。接下来还需要分别处理这两个序列，因为 6左边和右边的序列目前都还是很混 乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理 6左边和右 边的序列即可。现在先来处理 6左边的序列吧。如果你模拟得没有错，调整完毕之后的序列的顺序应该是：<br><strong>2  1  3  5  4</strong><br>OK，现在 3已经归位。接下来需要处理 3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以 2为基准数进行调整，处理完毕之后的序列为“1 2”，到此 2已经归位。序列 “1”只有一个数，也不需要进行任何处理。至此我们对序列“2 1”已全部处理完毕，得到 的序列是“1 2”。序列“5 4”的处理也仿照此方法，后得到的序列如下。<br>*<em>1  2  3  4  5  6  9  7  10  8 *</em><br>对于序列“9  7  10  8”也模拟刚才的过程，直到不可拆分出新的子序列为止。终将会得到这样的序列：</p><p>*<em>1  2  3  4  5  6  7  8  9  10 *</em></p><p>到此，排序完全结束。细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。</p><p>快速排序之所以比较快，是因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样只能在相邻的数之间进行交换，交换的距离就大得多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的差时间复杂度和 冒泡排序是一样的，都是 O(N2)，它的平均时间复杂度为 O (NlogN)。其实快速排序是基于一 种叫做“二分”的思想。它的java 代码如下： </p><pre><code class="java">public static int[] quickQuery(int a[],int begin,int end) {        if (begin &lt; end) {            int temp = a[begin];            int i = begin;            int j = end;            while(i != j) {                while(i &lt; j &amp;&amp; a[j] &gt;= temp) {                    j--;                }                while(i &lt; j &amp;&amp; a[i] &lt;= temp){                    i++;                }                if(i &lt; j){                   int t = a[j];                   a[j] = a[i];                   a[i] = t;                }            }            a[begin] = a[i];            a[i] = temp;            quickQuery(a,begin,j-1);            quickQuery(a,j+1,end);        }else{            return a;        }        return a;    }</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo教程</title>
      <link href="/posts/ff36.html"/>
      <url>/posts/ff36.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo博客搭建"><a href="#Hexo博客搭建" class="headerlink" title="Hexo博客搭建"></a>Hexo博客搭建</h1><p>1.安装Hexo运行环境</p><p>首先我们要安装Node.js，安装非常简单，Node.js安装完成后的检验操作是在DOS窗口下输入命令 <code>node -v</code>和<code>npm -v</code>，这两个命令就是查看版本信息的。 </p><p>2.安装hexo框架 </p><p>可以使用国内的镜像源安装：<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><p>接下来正式安装：</p><p><code>cnpm install -g hexo-cli</code></p><p>可以使用<code>hexo -v</code>验证一下，然后新建一个文件夹，用于存放博客的文件，在安装了git之后，右键选择git bash here ，弹出Git Bash窗口 ，执行<code>hexo init</code>命令初始化，<code>hexo g</code>编译生成静态页面，然后用<code>hexo s</code>启动博客在浏览器中访问<code>http://localhost:4000</code>，至此安装成功。</p><p>如果想写一篇文章，使用<code>hexo n &quot;HelloWorld&quot;</code>,在<code>blog\source\_posts</code>目录下去编辑即可。</p><p>3.部署到github</p><p>在github上新建一个仓库，仓库名必须是<code>用户名.github.io</code></p><p>为Hexo安装GIt插件<code>cnpm install hexo-deployer-git --save</code></p><p>修改 _config.yml 配置文件如下：</p><pre><code class="yaml">## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: https://github.com/xxx/xxx.github.io.git  branch: master</code></pre><p>部署到远端，使用<code>hexo d</code>命令，就OK了。</p><p>4.博客主题优化</p><p>（1）更换博客主题 <a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia主题官网</a></p><p>可以去查看自己喜欢的主题 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a> </p><p>我们下载yilia这个主题<code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code></p><p>然后修改hexo根目录下的 <code>_config.yml</code> ： <code>theme: yilia</code> 即可。</p><p>（2） <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">matery主题官网</a></p><p>修改主题的logo图和favicon图标</p><pre><code class="yaml">favicon: /favicon.pnglogo: /favicon.png</code></pre><p>去掉右上角的github图标，打开你的主题配置文件，找到下面的配置:</p><pre><code class="yaml"># 配置是否在 header 中显示 fork me on github 的图标，默认为true，你可以修改为你的仓库地址.githubLink:  enable: true  url: https://github.com/blinkfox/hexo-theme-matery  title: Fork Me</code></pre><p>去掉主页的Github按钮，打开主题配置文件，找到下面的配置： 将enable属性值由true改为fals即可。 </p><pre><code class="yaml"># 首页 banner 中的第二个按钮的配置，包括按钮的显示名称、font awesome图标和按钮的超链接.indexbtn:  enable: true  name: Github  icon: fab fa-github-alt  url: https://github.com/blinkfox/hexo-theme-matery</code></pre><p>修改社交链接</p><pre><code class="yaml"># 首页 banner 中的第二行个人信息配置，留空即不启用socialLink:        ...</code></pre><p>修改导航栏颜色及透明效果:<br>打开<code>themes/hexo-theme-matery/source/css/matery.css</code>文件，在252行，有一个<code>.bg-color</code>属性，修改其属性值即可，代码如下：</p><pre><code class="yaml">.bg-color {    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%); //修改成自己喜欢的颜色值    opacity: 0.8;  //透明效果 值范围 0~1，看情况自己修改}</code></pre><p>修改banner图和文章特色图:<br>你可以直接在 <code>/source/medias/banner</code>文件夹中更换你喜欢的 banner 图片，主题代码中是每天动态切换一张，只需 7 张即可。如果你会 JavaScript 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，banner 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code>文件的 <code>&lt;script&gt;&lt;/script&gt;</code>代码中：</p><pre><code class="javascript">$(&#39;.bg-cover&#39;).css(&#39;background-image&#39;, &#39;url(/medias/banner/&#39; + new Date().getDay() + &#39;.jpg)&#39;);</code></pre><p>在 <code>/source/medias/featureimages</code>文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 _config.yml 做同步修改。如果想改为每小时或者每分钟切换banner图的话，需要将<code>getDay()</code>改为<code>getHours()</code>或者<code>getMinutes()</code>即可。</p><p>添加首页动态打字效果副标题:</p><pre><code class="yaml"># 打字效果副标题.# 如果有符号 ‘ ，请在 ’ 前面加上 \subtitle:        ...</code></pre><p>大致的美化工作就完成了！小伙伴不满意的话可以自己在定义。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git概述</title>
      <link href="/posts/6122.html"/>
      <url>/posts/6122.html</url>
      
        <content type="html"><![CDATA[<p><strong>1.Git安装</strong></p><p><strong>2.Git入门</strong></p><p>新建一个文件夹，使用<code>git init</code>命令这个目录变成Git可以管理的仓库。</p><p>设置系统用户级别，<code>git config --global user.name &quot;Your Name&quot;</code></p><p><code>git config --global user.email &quot;email@example.com&quot;</code> </p><p>可以在.gitconfig下查看</p><pre><code class="java">$ cat .gitconfig[user]        name = xxx        email = email@2765221869@qq.com</code></pre><p><code>git status</code>，查看状态</p><p><code>git add [FileName]</code>,添加操作</p><p><code>git commit -m &quot;文件说明&quot; [FileName]</code>，提交</p><p><strong>版本穿梭</strong></p><p><code>git log</code>，显示从最近到最远的提交日志，<code>git log --pretty=oneline</code> ,<code>git reflog</code></p><p><code>git reset --hard 647b18b</code>,基于索引值到指定的版本</p><p><code>git reset --hard HEAD^</code>，<code>git reset --hard~n</code>,回退</p><p><code>git help reset</code>:可以查看帮助文档</p><pre><code class="java">reset的三个参数对比    --soft:仅在本地库移动HEAD指针    --mixed:在本地库移动HEAD指针,重置暂存区    --hard:在本地库移动HEAD指针,重置暂存区和工作区</code></pre><p>删除文件找回：回退到历史记录</p><p><code>git diff</code>,比较工作区与暂存区的区别；</p><p><code>git diff --cached</code>,比较暂存区与版本库的区别。</p><p> <code>git diff HEAD -- readme.txt</code>, 查看工作区和版本库里面最新版本的区别  </p><p>修改的操作</p><p> <code>git checkout -- readme.txt</code></p><p>当<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>当<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p> <code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区</p><p>删除操作</p><p>执行<code>git rm test.txt</code>后，然后执行<code>git commit -m &quot;remove test.txt&quot;</code></p><p><strong>分支操作：</strong></p><p><code>git branch dev</code>,创建分支。<code>git checkout dev</code>, <code>git switch dev</code>切换分支。<code>git branch -v</code>,查看分支</p><p><code>git merge dev</code>,合并分支，<code>git branch -d dev</code>,删除分支。</p><p><code>git stash</code>,保存现在的工作现场</p><p><code>git stash drop</code> , 恢复的同时把stash内容也删了</p><p><code>git stash list</code></p><p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p><p><code>git stash apply stash@{0}</code></p><p><strong>远程仓库：</strong></p><p> 已经在本地创建了一个Git仓库后，又在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步 </p><p><code>git remote add origin git@github.com:michaelliao/learngit.git</code></p><p><code>git push origin master</code>,推送到远程库</p><p><code>git pull origin master</code>,拉取仓库到本地</p><p><code>git clone git@github.com:michaelliao/gitskills.git</code>,克隆仓库</p><p>将别人的仓库fork到自己的仓库下面，然后clone到本地，做出修改后推送给别人。</p><p><strong>SSH免密登录：</strong></p><p>进入当前目录的家目录：<code>cd ~</code>,删除.ssh目录<code>rm -rvf .ssh</code>，运行<code>ssh-keygen -t rsa -C email.com</code>命令生成.ssh秘钥目录,将.ssh下的id_rsa.pub内容复制到gitHub中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/posts/a01f.html"/>
      <url>/posts/a01f.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="一、为什么需要docker"><a href="#一、为什么需要docker" class="headerlink" title="一、为什么需要docker?"></a>一、为什么需要docker?</h2><p><a href="https://www.docker-cn.com/" target="_blank" rel="noopener">Docker官网</a></p><p>环境切换、配置麻烦</p><p>解决应用之间的隔离，比如在同一个服务器上部署两个应用。</p><ul><li>软件更新发布及部署低效，过程繁琐且需要人工介入</li><li>环境一致性难以保证</li><li>不同环境之间迁移成本太高</li></ul><p><strong>Docker与虚拟机的区别：</strong></p><p>虚拟机实现资源隔离的方法是利用独立的OS，并利用Hypervisor虚拟化CPU、内存、IO设备等实现的。 docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有优势。</p><p>虚拟机的Hypervisor层可以简单理解为一个硬件虚拟化平台，它在Host OS是以内核态的驱动存在的。 </p><p>docker利用的是宿主机的内核，而不需要Guest OS。因此，当新建一个容器时，docker不需要和虚拟机一样重新加载一个操作系统内核。</p><h2 id="二、docker概述"><a href="#二、docker概述" class="headerlink" title="二、docker概述"></a>二、docker概述</h2><p> Docker基本组成：仓库、镜像、容器</p><p> 容器是用镜像创建的运行实例。</p><p> 仓库是保存镜像文件的场所。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/12581a/cdn/images/docker.png" alt></p><p>​                                                                                dokcer架构图</p><p>开启docker，<code>systemctl start docker</code>,阿里云镜像加速器配置<code>/etc/docker/daemon.json</code>文件。</p><p>执行完<code>docker run hello-world</code>命令后，由于本地没有这个镜像，会下载一个镜像在容器内运行。</p><p>Docker是一个C/S结构的系统，Docker守护进程运行在主机上，通过Socket连接从客户端访问，守护进程管理运行在主机上的容器。</p><p><strong>docker常用命令：</strong></p><p><strong>镜像命令：</strong></p><p><code>docker images</code>:列出本地主机上的镜像</p><p><code>dokcer images -q</code>:只显示镜像的ID</p><p><code>docker search -s 30 tomcat</code>:搜索hub上star大于30的tomcat的镜像</p><ul><li><p>–no-trunc:显示完整的镜像描述。</p></li><li><p>-s:列出收藏数不小于 指定值的镜像。</p></li><li><p>-automated:只列出automated build类型的镜像。</p></li></ul><p><code>docker pull tomcat:latest</code>:下载镜像,自动添加最新版本 </p><p><code>docker rmi hello-world/镜像ID</code>:删除镜像</p><p><code>docker rmi -f redis tomcat nginx</code>:删除多个镜像</p><p><code>docker rmi -f $(docker images -aq)</code>:删除全部</p><p><strong>容器命令：</strong></p><p><code>docker run -it 容器ID</code>:运行容器</p><ul><li>-i:以交互模式运行容器</li><li>-t:为容器重新分配一个伪终端</li><li>-d:后台运行容器，并返回容器ID,也即启动守护式进程</li><li>–name=”容器新名字”：为容器指定一个名称</li><li>-P: 随机端口映射</li></ul><p><code>docker run -it -P tomcat</code></p><ul><li>-p:指定端口映射</li></ul><p><code>docker run -it -p 8080:8080 tomcat</code></p><p><code>docker ps -a</code>:列出当前所有正在运行的容器</p><p><code>exit、ctrl+P+Q</code>:退出容器、容器不停止退出,第二种重新进入的命令<code>docker attach 容器ID</code></p><p><code>docker start 容器ID</code>：启动容器</p><p><code>docker stop 容器ID</code>:停止容器</p><p><code>docker rm 容器ID</code>:删除容器</p><p><code>docker logs -f -t tail 容器ID</code>:查看容器日志</p><p><code>docker cp 容器ID 容器内路径</code>:从容器内拷贝文件到主机上</p><p><code>docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 新命名</code></p><p><code>docker exec -it 容器ID /bin/bash</code>:进入容器</p><p><strong>docker镜像原理</strong></p><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于环境开发的软件，它包含运行这个软件所需的所有的内容，包括代码、运行时、库、环境变量和配置文件。</p><p><strong>Docker容器数据卷</strong></p><p>卷设计的目的就是数据的持久化，完全独立于容器的生命周期。</p><p>特点：</p><ul><li>数据卷可在容器之间共享或重用数据</li><li>对数据卷内数据的修改会立马生效，无论是容器内操作还是本地操作；</li><li>数据卷中的更改不会包含在镜像的更新中</li><li>数据卷的生命周期一直持续到没有容器使用它为止 </li></ul><p>数据卷容器内添加有两种方式，一种是直接命令添加，还有一种是DockerFile添加</p><p>执行命令，宿主机中会出现myDataVolume文件夹，容器中的centos会出现data文件夹，两个文件夹共享数据</p><pre><code class="java">docker run -it -v /myDataVolume:/dataVolumeContainer centos</code></pre><p>DockerFile解析：</p><p>DockerFile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。</p><p>新建一个dockerfile文件：</p><pre><code class="java">FROM centosVOLUME [&quot;/dataVolumeContainer1&quot;,&quot;/dataVolumeContainer2&quot;]CMD echo &quot;finished,-------success1&quot;CMD  /bin/bash</code></pre><pre><code class="java">docker build -f /mydocker/DockerFile -t zy/centos .</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
